1. Módulo “Obras”
1.1. Alta de obra con validaciones y auditoría
markdown
Copiar
Editar
Escribe el método `alta_obra(self, datos)` dentro de `ObrasController` (archivo modules/obras/controller.py) que:
1. Reciba un diccionario con llaves: “nombre”, “cliente_id”, “fecha_medicion” (YYYY-MM-DD) y “fecha_entrega” (YYYY-MM-DD).
2. En el backend (sin acceder directamente al QDialog), valide que “nombre” y “cliente_id” no estén vacíos, y que `fecha_entrega > fecha_medicion`. 
   - Si alguna validación falla, lance `ValueError("Mensaje claro del error")`.
3. Inserte la nueva obra en la tabla `obras` dentro de una transacción con timeout=30 y retries=2. 
   - La tabla debe tener columna `rowversion` que se genere automáticamente. 
   - Después de insertar, recupere el `id_obra` y el `rowversion` generado.
4. Genere automáticamente la primera etapa (por ejemplo, “Fabricación”) con fecha “fecha_medicion + 90 días” y guárdala en la tabla `etapas_obras` (o donde corresponda). 
5. Registre un evento en `auditorias_sistema` usando el helper `_registrar_evento_auditoria(usuario, "Obras", f"Creó obra {id_obra}")`.
6. Retorne el `id_obra` recién creado.
Guarda este fragmento en modules/obras/controller.py, dentro de la clase ObrasController.
1.2. Edición de obra con rowversion y captura de conflictos
java
Copiar
Editar
Implementa el método `editar_obra(self, id_obra, datos, rowversion_orig)` en `modules/obras/controller.py` que:
1. Revise que los campos “nombre”, “cliente_id”, “fecha_medicion” y “fecha_entrega” cumplan las mismas validaciones que en alta (no vacíos y fecha_entrega > fecha_medicion).
   - Si falla, lance `ValueError("Mensaje del error")`.
2. Dentro de una transacción (timeout=30, retries=2), ejecute:
   ```sql
   UPDATE obras
   SET nombre = ?, cliente_id = ?, fecha_medicion = ?, fecha_entrega = ?
   WHERE id_obra = ? AND rowversion = ?
usando los valores de datos y rowversion_orig.
3. Si el número de filas afectadas es 0, lance OptimisticLockError("Otro usuario actualizó esta obra previamente").
4. Si la actualización fue exitosa, obtenga el nuevo rowversion y registre auditoría:
_registrar_evento_auditoria(usuario, "Obras", f"Editó obra {id_obra}").
5. Retorne el nuevo rowversion.
Añade este método en la clase ObrasController, y asegúrate de importar o definir OptimisticLockError.

shell
Copiar
Editar

### 1.3. Tests unitarios para ObrasModel
Crea un archivo tests/obras/test_obras_model.py con pytest que:

Use un fixture que cree una base SQLite en memoria con la tabla obras (incluyendo la columna rowversion) y un método ObrasModel que conecte a esa base.

Escriba una prueba test_listar_obras_vacia que invoque listar_obras() y compruebe que retorne lista vacía.

Escriba una prueba test_insertar_y_listar_obra que inserte directamente via SQL una fila en obras (con nombre="Prueba", cliente_id=1, fechas válidas) y luego llame a listar_obras() y verifique que la fila encontrada tenga todos los campos correctos, incluido rowversion.

Escriba una prueba test_editar_obra_conflicto_rowversion que:

Inserte una fila, obtenga id_obra y rowversion_orig.

Actualice manualmente la fila para cambiar su rowversion (simulando edición concurrente).

Llame a editar_obra(id_obra, datos_modificados, rowversion_orig) y espere que lance OptimisticLockError.

Usa asserts de pytest y asegúrate de cerrar la conexión al final de cada prueba.

shell
Copiar
Editar

### 1.4. Test de integración para ObrasController
Crea un archivo tests/obras/test_obras_controller_integracion.py con pytest que:

Use un fixture para inicializar una base SQLite en memoria y registrar la tabla obras y la tabla de auditoría (auditorias_sistema).

Importe ObrasController y ObrasModel.

Prueba test_alta_obra_exitoso que:

Cree datos válidos ({"nombre":"Obra1","cliente_id":2,"fecha_medicion":"2025-06-01","fecha_entrega":"2025-07-01"}).

Llame a alta_obra(datos) y reciba un id_obra.

Verifique que ObrasModel.listar_obras() retorne exactamente una fila con id_obra, nombre “Obra1” y un rowversion no nulo.

Verifique que en auditorias_sistema exista un registro con módulo “Obras” y acción “Creó obra {id_obra}”.

Prueba test_editar_obra_exitoso que:

Inserte manualmente una obra con SQL y obtenga id_obra y rowversion_orig.

Llame a editar_obra(id_obra, datos_modificados, rowversion_orig) con datos_modificados cambiando el nombre.

Verifique que listar_obras() devuelva la obra con el nombre actualizado y nuevo rowversion.

Verifique que en auditoría exista un registro “Editó obra {id_obra}”.

Prueba test_editar_obra_conflicto que:

Inserte una obra, obtenga id_obra y rowversion_orig.

Actualice la fila directamente por SQL para cambiar rowversion.

Llame a editar_obra(id_obra, datos, rowversion_orig) y espere OptimisticLockError.

yaml
Copiar
Editar

---

## 2. Módulo “Pedidos de Material”

### 2.1. Método `generar_pedido_por_obra` en PedidosModel
En el archivo modules/pedidos/model.py, implementa el método:

python
Copiar
Editar
def generar_pedido_por_obra(self, id_obra):
    """
    1. Consulte todas las reservas de perfiles, herrajes y vidrios para id_obra:
       - SELECT id_perfil, cantidad_reservada, stock_actual FROM inventario_perfiles JOIN perfiles_por_obra ON …
       - SELECT id_herraje, cantidad_reservada, stock_actual FROM herrajes JOIN herrajes_por_obra ON …
       - SELECT id_vidrio, cantidad_reservada, stock_actual FROM vidrios JOIN vidrios_por_obra ON …
    2. Para cada ítem, calcule faltante = cantidad_reservada - stock_actual (si es > 0).
    3. Si faltante > 0, agrégalo a la lista de ítems a pedir.
    4. Inserte un nuevo registro en `pedidos` con campos: (fecha_emision=NOW(), estado='Pendiente', id_obra, total_estimado = SUM(faltante * precio_unitario aproximado por ítem)).
    5. Obtenga el `id_pedido` recién insertado.
    6. Para cada ítem faltante, inserte en `pedidos_por_obra(id_pedido, id_obra, id_item, cantidad_requerida=faltante)` (separando por tipo: perfil, herraje o vidrio).
    7. Registrar en `auditorias_sistema` (“Usuario X generó pedido {id_pedido} para obra {id_obra}”).
    8. Retornar `id_pedido`.
Use transacciones con timeout=30 y retries=2.  
2.2. Método recibir_pedido en PedidosModel
csharp
Copiar
Editar
En `modules/pedidos/model.py`, implementa:
```python
def recibir_pedido(self, id_pedido):
    """
    1. Consulte si el pedido existe y su estado es 'Pendiente' o 'En Camino'; si estado es 'Recibido', lanzar ValueError("Pedido ya recibido").
    2. Cambie estado de pedido a 'Recibido'.
    3. Para cada fila en pedidos_por_obra asociada a id_pedido:
       a. Dependiendo del tipo (perfil, herraje o vidrio), actualice la tabla de inventario correspondiente sumando cantidad_recibida a stock_actual.
       b. Inserte un registro en movimientos_stock (o movimientos_herrajes/movimientos_vidrios) con tipo 'Ingreso' y fecha=NOW().
    4. Registrar auditoría (“Usuario X confirmó recepción del pedido {id_pedido}”).
    5. Retornar True.
Use transacción con timeout=30 y retries=2.
2.3. Test unitario para PedidosModel
markdown
Copiar
Editar
Crea `tests/compras/test_pedidos_model.py` con pytest que:
1. Use un fixture para SQLite en memoria que cree tablas `obras`, `inventario_perfiles`, `perfiles_por_obra`, `movimientos_stock`, `pedidos`, `pedidos_por_obra`.
2. Inserte manualmente:
   - Una obra con id_obra=1.
   - Un perfil con id_perfil=1, stock_actual=5, precio_unitario=100.
   - En `perfiles_por_obra` para id_obra=1 y id_perfil=1, cantidad_reservada=10.
3. Llame a `generar_pedido_por_obra(1)` y verifique:
   - Retorna un id_pedido > 0.
   - En `pedidos` exista fila con estado='Pendiente' y total_estimado = (10 - 5) * 100 = 500.
   - En `pedidos_por_obra` exista fila con id_item=1, cantidad_requerida=5.
4. Llame a `recibir_pedido(id_pedido)` y verifique:
   - `pedidos.estado` para id_pedido ahora es 'Recibido'.
   - `inventario_perfiles.stock_actual` pasó de 5 a 10 (sumó las 5 unidades recibidas).
   - Existe un registro en `movimientos_stock` con tipo='Ingreso' y cantidad=5.
5. Llamar nuevamente `recibir_pedido(id_pedido)` y verificar que lance `ValueError("Pedido ya recibido")`.
2.4. Test de integración para PedidosController
perl
Copiar
Editar
Crea `tests/compras/test_pedidos_controller.py` con pytest que:
1. Use un MockDBConnection o SQLite en memoria para simular las tablas necesarias (obras, inventario_perfiles, perfiles_por_obra, pedidos, pedidos_por_obra, movimientos_stock, auditorias_sistema).
2. Simule un usuario con rol “Admin” (tiene permiso “crear” y “editar” en pedidos).
3. Prueba `test_crear_pedido_con_permisos` que:
   - Llame a `crear_pedido(1)` en PedidosController (obra_id=1) y verifique que internamente llame a `PedidosModel.generar_pedido_por_obra(1)`.
   - Verifique que en auditoría haya registro “Usuario Admin generó pedido X para obra 1”.
4. Prueba `test_crear_pedido_sin_permisos` que:
   - Use un usuario con rol “Operario” (sin permiso “crear” en pedidos).
   - Llame a `crear_pedido(1)` y espere `ValueError("Permisos insuficientes")`.
5. Prueba `test_recibir_pedido_con_permisos` que:
   - Inserte un pedido “Pendiente” (con id_pedido simulado) en la base, y llame `recibir_pedido(id_pedido)` desde el controlador.
   - Verifique que se actualice stock en inventario y exista auditoría “Usuario Admin confirmó recepción del pedido {id_pedido}”.
6. Prueba `test_recibir_pedido_sin_permisos` que:
   - Use un usuario sin permiso “editar” y espere `ValueError("Permisos insuficientes")`.
3. Inventario de Perfiles
3.1. Métodos pendientes en InventarioModel
markdown
Copiar
Editar
En `modules/inventario/model.py`, implementa:
1. `def reservar_perfil(self, id_obra, id_perfil, cantidad):`
   - Si `cantidad > stock_actual` en `inventario_perfiles`, lance `ValueError("Stock insuficiente")`.
   - Reste `stock_actual -= cantidad` y actualice la fila en `inventario_perfiles`.
   - Inserte o actualice en `perfiles_por_obra(id_obra, id_perfil, cantidad_reservada, estado='Reservado')`.
   - Inserte en `movimientos_stock(id_perfil=id_perfil, tipo_movimiento='Egreso', cantidad=cantidad, fecha=NOW(), usuario)`.
   - Registrar auditoría “Usuario X reservó {cantidad} del perfil {id_perfil} para obra {id_obra}”.
   - Retornar True.
2. `def devolver_perfil(self, id_obra, id_perfil, cantidad):`
   - Aumente en `stock_actual += cantidad` la tabla `inventario_perfiles`.
   - Actualice o elimine la fila en `perfiles_por_obra` (disminuyendo `cantidad_reservada` o marcando `estado='Liberado'`).
   - Inserte en `movimientos_stock(tipo_movimiento='Ingreso', cantidad=cantidad, fecha=NOW(), usuario)`.
   - Registrar auditoría “Usuario X devolvió {cantidad} del perfil {id_perfil} de la obra {id_obra}”.
   - Retornar True.
3. `def ajustar_stock_perfil(self, id_perfil, nueva_cantidad, usuario):`
   - Si `nueva_cantidad < 0`, lance `ValueError("Cantidad inválida")`.
   - Obtenga `stock_anterior` de `inventario_perfiles`.
   - Actualice `stock_actual = nueva_cantidad`.
   - Inserte en `movimientos_stock` un registro con tipo “Ajuste” y cantidad = abs(nueva_cantidad – stock_anterior), fecha=NOW(), usuario.
   - Registrar auditoría “Usuario X ajustó stock del perfil {id_perfil} de {stock_anterior} a {nueva_cantidad}”.
   - Retornar True.
Usa transacciones con timeout=30 y retries=2 en cada método.
3.2. UI de Inventario (Perfiles) en InventarioController e InventarioView
markdown
Copiar
Editar
Crea o completa `modules/inventario/view.py` y `modules/inventario/controller.py` para:
1. En `InventarioController`, agregar señales y slots:
   - `reservar_perfil_signal(id_obra, id_perfil, cantidad)` conectado a `reservar_perfil`.
   - `devolver_perfil_signal(id_obra, id_perfil, cantidad)` conectado a `devolver_perfil`.
2. El método `reservar_perfil(self, id_obra, id_perfil, cantidad)` invoque `InventarioModel.reservar_perfil` y capture ValueError para mostrar `QMessageBox.warning`.
3. Similar para `devolver_perfil`.
4. En `InventarioView`, diseñar un formulario:
   - `QComboBox` con todos los perfiles (`self.cmb_perfiles.addItems(…)`), cargados desde el modelo.
   - `QSpinBox` para cantidad (rango 1-`stock_actual`).
   - Botón “Reservar perfil” que emita `reservar_perfil_signal`.
   - Botón “Devolver perfil” que emita `devolver_perfil_signal`.
   - Una `QTableWidget` para “Perfiles por Obra” que muestre [NombrePerfil, CantidadReservada, Estado, Fecha].
   - Una sección “Alertas de Stock” que liste en rojo los perfiles con `stock_actual ≤ stock_minimo`.
5. En `InventarioController`, cada vez que se ejecute una reserva o devolución, refrescar la tabla con `listar_perfiles_por_obra(id_obra)` y recargar los perfiles en el dropdown.
3.3. Test unitario para InventarioModel (Perfiles)
markdown
Copiar
Editar
Crea `tests/inventario/test_inventario_perfiles_model.py` que:
1. Use un fixture de SQLite en memoria para crear tablas: `inventario_perfiles`, `perfiles_por_obra`, `movimientos_stock`, `auditorias_sistema`.
2. Inserte un perfil con `id_perfil=1, nombre='Perfil1', stock_actual=10, stock_minimo=3, precio_unitario=50`.
3. Pruebe `test_reservar_perfil_exitoso` que:
   - Llame a `reservar_perfil(obra_id=1, id_perfil=1, cantidad=5)` y verifique que ahora `stock_actual` es 5.
   - Compruebe que en `perfiles_por_obra` hay fila con `cantidad_reservada=5` y `estado='Reservado'`.
   - Verifique que en `movimientos_stock` exista un registro con `tipo_movimiento='Egreso'` y `cantidad=5`.
4. Pruebe `test_reservar_perfil_insuficiente` que:
   - Llame a `reservar_perfil(obra_id=1, id_perfil=1, cantidad=20)` y espere `ValueError("Stock insuficiente")`.
5. Pruebe `test_devolver_perfil_exitoso` que:
   - Primero haga una reserva (llama a `reservar_perfil`).
   - Luego `devolver_perfil(obra_id=1, id_perfil=1, cantidad=3)` y verifique que `stock_actual` quedó en 8.
   - Que el registro en `perfiles_por_obra` se haya actualizado o eliminado.
   - Que en `movimientos_stock` exista un registro con `tipo_movimiento='Ingreso'` y `cantidad=3`.
6. Pruebe `test_ajustar_stock_invalido` que:
   - Llame a `ajustar_stock_perfil(id_perfil=1, nueva_cantidad=-2, usuario="test")` y espere `ValueError("Cantidad inválida")`.
3.4. Test de integración para InventarioController (Perfiles)
markdown
Copiar
Editar
Crea `tests/inventario/test_inventario_perfiles_controller.py` que:
1. Use un MockDBConnection en SQLite memoria para las mismas tablas que el modelo.
2. Simule un usuario con permiso “crear” y llame `reservar_material(id_perfil=1, cantidad=5, id_obra=1)` en `InventarioController`. Verifique:
   - Que no arroja error.
   - Que en la BD `inventario_perfiles.stock_actual` es 5.
   - Que en auditoría existe “Usuario Test reservó 5 del perfil 1 para obra 1”.
3. Simule un usuario sin permiso “crear” e intente `reservar_material`, espere `ValueError("Permisos insuficientes")`.
4. Simule `devolver_material(id_perfil=1, cantidad=3, id_obra=1)` con permiso “editar” y verifique:
   - `stock_actual` pasó a 8.
   - Auditoría “Usuario Test devolvió 3 del perfil 1 de la obra 1”.
5. Sin permiso “editar”, `devolver_material` debe lanzar `ValueError("Permisos insuficientes")`.
4. Herrajes y Vidrios
4.1. Métodos en HerrajesModel
markdown
Copiar
Editar
En `modules/herrajes/model.py`, implementa:
1. `def reservar_herraje(self, id_obra, id_herraje, cantidad):`
   - Si `cantidad > stock_actual` en `herrajes`, lanzar `ValueError("Stock insuficiente")`.
   - Restar `stock_actual -= cantidad`.
   - Insertar/actualizar en `herrajes_por_obra(id_obra, id_herraje, cantidad_reservada, estado='Reservado')`.
   - Insertar en `movimientos_herrajes(id_herraje, tipo_movimiento='Egreso', cantidad, fecha=NOW(), usuario)`.
   - Registrar auditoría “Usuario X reservó {cantidad} del herraje {id_herraje} para obra {id_obra}”.
   - Retornar True.
2. `def devolver_herraje(self, id_obra, id_herraje, cantidad):`
   - Aumentar `stock_actual += cantidad`.
   - Actualizar o eliminar fila en `herrajes_por_obra`.
   - Insertar en `movimientos_herrajes(tipo_movimiento='Ingreso', cantidad, fecha=NOW(), usuario)`.
   - Registrar auditoría “Usuario X devolvió {cantidad} del herraje {id_herraje} de la obra {id_obra}”.
   - Retornar True.
3. `def ajustar_stock_herraje(self, id_herraje, nueva_cantidad, usuario):`
   - Si `nueva_cantidad < 0`, lanzar `ValueError("Cantidad inválida")`.
   - Obtener `stock_anterior`, actualizar `stock_actual = nueva_cantidad`.
   - Insertar en `movimientos_herrajes(tipo_movimiento='Ajuste', cantidad=abs(nueva_cantidad − stock_anterior), fecha=NOW(), usuario)`.
   - Registrar auditoría “Usuario X ajustó stock del herraje {id_herraje} de {stock_anterior} a {nueva_cantidad}”.
   - Retornar True.
Usa transacciones con timeout=30 y retries=2.
4.2. Métodos en VidriosModel
python
Copiar
Editar
En `modules/vidrios/model.py`, implementa de forma análoga a HerrajesModel:
1. `def reservar_vidrio(self, id_obra, id_vidrio, cantidad):`
   - Validar stock_actual ≥ cantidad.
   - Restar stock_actual, insertar/actualizar en `vidrios_por_obra`.
   - Insertar en `movimientos_vidrios(tipo_movimiento='Egreso', cantidad, fecha=NOW(), usuario)`.
   - Registrar auditoría “Usuario X reservó {cantidad} del vidrio {id_vidrio} para obra {id_obra}”.
   - Retornar True.
2. `def devolver_vidrio(self, id_obra, id_vidrio, cantidad):`
   - Aumentar stock_actual, actualizar/eliminar `vidrios_por_obra`.
   - Insertar `movimientos_vidrios(tipo_movimiento='Ingreso', cantidad, fecha=NOW(), usuario)`.
   - Registrar auditoría “Usuario X devolvió {cantidad} del vidrio {id_vidrio} de la obra {id_obra}”.
   - Retornar True.
3. `def ajustar_stock_vidrio(self, id_vidrio, nueva_cantidad, usuario):`
   - Si nueva_cantidad < 0, lanzar `ValueError("Cantidad inválida")`.
   - Actualizar stock_actual, insertar en `movimientos_vidrios(tipo_movimiento='Ajuste', cantidad=abs(nueva_cantidad − stock_anterior), fecha=NOW(), usuario)`.
   - Registrar auditoría “Usuario X ajustó stock del vidrio {id_vidrio} de {stock_anterior} a {nueva_cantidad}”.
   - Retornar True.
Usa transacciones con timeout=30 y retries=2.
4.3. UI de Herrajes y Vidrios en View/Controller
markdown
Copiar
Editar
En `modules/herrajes/view.py` y `modules/herrajes/controller.py`:
1. En el Controller, definir señales:
   - `reservar_herraje_signal(id_obra, id_herraje, cantidad)`.
   - `devolver_herraje_signal(id_obra, id_herraje, cantidad)`.
   - Conectar esas señales a los métodos `reservar_herraje` y `devolver_herraje` del modelo.
2. En la Vista (`HerrajesView`):
   - `QComboBox` con lista de obras (id_obra).
   - `QComboBox` o `QLineEdit+QCompleter` con lista de herrajes (nombre y stock_actual).
   - `QSpinBox` para cantidad.
   - Botón “Reservar herraje” que emita `reservar_herraje_signal`.
   - Botón “Devolver herraje” que emita `devolver_herraje_signal`.
   - `QTableWidget` para “Herrajes por Obra” mostrando [NombreHerraje, CantidadReservada, Estado, Fecha].
   - Colorear en rojo las filas cuyo stock_actual ≤ stock_minimo.

En `modules/vidrios/view.py` y `modules/vidrios/controller.py` haz lo mismo para vidrios.
4.4. Tests para HerrajesModel y VidriosModel
markdown
Copiar
Editar
Crea `tests/herrajes/test_herrajes_model.py`:
1. Fixture SQLite en memoria con tablas: `herrajes`, `herrajes_por_obra`, `movimientos_herrajes`, `auditorias_sistema`.
2. Inserte un herraje con `id_herraje=1, stock_actual=20, stock_minimo=5`.
3. Pruebas:
   - `test_reservar_herraje_exitoso`: reservar 10 y comprobar stock pasa a 10, reserva en `herrajes_por_obra` y movimiento “Egreso”.
   - `test_reservar_herraje_insuficiente`: intentar reservar 30 y esperar `ValueError("Stock insuficiente")`.
   - `test_devolver_herraje_exitoso`: reservar 10, luego devolver 5, comprobar stock=15, movimiento “Ingreso”.
   - `test_ajustar_stock_herraje_invalido`: llamar con nueva_cantidad=-3 y esperar `ValueError("Cantidad inválida")`.

Crea `tests/vidrios/test_vidrios_model.py` análogo a herrajes, pero con tablas `vidrios`, `vidrios_por_obra`, `movimientos_vidrios`.
4.5. Tests para HerrajesController y VidriosController
markdown
Copiar
Editar
Crea `tests/herrajes/test_herrajes_controller.py`:
1. Fixture con MockDBConnection para herrajes.
2. Usuario “Admin” con permiso “crear” llame `asociar_herraje(obra_id=1, id_herraje=1, cantidad=5)` y verifique DB y auditoría.
3. Usuario sin permiso “crear” espere `ValueError("Permisos insuficientes")`.
4. Usuario con permiso “editar” llame `devolver_herraje_control(obra_id=1, id_herraje=1)` y verifique DB y auditoría.
5. Sin permiso “editar” espere `ValueError("Permisos insuficientes")`.

Crea `tests/vidrios/test_vidrios_controller.py` con el mismo esquema para vidrios.
5. “Perfiles por obra” y “Lista de Precios”
5.1. Consultar perfiles por obra en InventarioModel
python
Copiar
Editar
En `modules/inventario/model.py` agrega:
```python
def obtener_perfiles_por_obra(self, id_obra):
    """
    Retorna lista de tuplas (nombre_perfil, cantidad_reservada, estado, fecha)
    para todos los perfiles asociados a id_obra.
    """
    sql = '''
      SELECT p.nombre_perfil, pp.cantidad_reservada, pp.estado, pp.fecha
      FROM perfiles_por_obra pp
      JOIN inventario_perfiles p ON pp.id_perfil = p.id_perfil
      WHERE pp.id_obra = ?
    '''
    return self.db.select_all(sql, (id_obra,))
shell
Copiar
Editar

### 5.2. UI para “Perfiles por Obra” en InventarioView
En modules/inventario/view.py, dentro de la clase InventarioView:

Agrega una nueva pestaña o sección “Perfiles por Obra” con un QTableWidget que muestre columnas [Perfil, CantidadReservada, Estado, Fecha].

En el Controller, define el método cargar_perfiles_por_obra(self, id_obra) que llame a InventarioModel.obtener_perfiles_por_obra(id_obra) y cargue los datos en la tabla.

En la UI, cada vez que se seleccione una obra del primer QComboBox, llame a cargar_perfiles_por_obra(id_obra).

shell
Copiar
Editar

### 5.3. Lista de precios de perfiles
En modules/inventario/controller.py, agrega:

python
Copiar
Editar
def obtener_lista_precios(self):
    """
    Retorna lista de tuplas (id_perfil, nombre_perfil, precio_unitario, stock_actual, stock_minimo).
    """
    sql = '''
      SELECT id_perfil, nombre_perfil, precio_unitario, stock_actual, stock_minimo
      FROM inventario_perfiles
    '''
    return self.db.select_all(sql)
En modules/inventario/view.py, crea una pestaña “Precios” con:

QTableWidget con columnas [Perfil, Precio unitario, Stock Actual, Stock Mínimo].

Botón “Editar precio” que abra un diálogo donde el usuario (si tiene permiso “editar”) pueda cambiar el precio. Al confirmar, llamar a InventarioController.actualizar_precio_perfil(id_perfil, nuevo_precio).

En el Controller, implementa actualizar_precio_perfil(id_perfil, nuevo_precio) que valide nuevo_precio ≥ 0, actualice inventario_perfiles.precio_unitario, registre auditoría “Usuario X actualizó precio del perfil {id_perfil} a {nuevo_precio}” y recargue la grilla.

shell
Copiar
Editar

### 5.4. Tests para “Perfiles por Obra” y “Precios”
Crea tests/inventario/test_perfiles_por_obra_model.py:

Fixture SQLite en memoria con tablas inventario_perfiles y perfiles_por_obra.

Inserte un perfil y una reserva para obra=1.

Llame obtener_perfiles_por_obra(1) y verifique que retorne (nombre_perfil, cantidad_reservada, estado, fecha).

Crea tests/inventario/test_precios_perfiles_controller.py:

Fixture con MockDBConnection.

Usuario con permiso “editar” llame actualizar_precio_perfil(id_perfil=1, nuevo_precio=200) y verifique que inventario_perfiles.precio_unitario pasó de su valor inicial a 200.
Verifique auditoría “Usuario Test actualizó precio del perfil 1 a 200”.

Usuario sin permiso “editar” llame a actualizar_precio_perfil y espere ValueError("Permisos insuficientes").

yaml
Copiar
Editar

---

## 6. Módulo “Configuración” y “Usuarios/Roles”

### 6.1. Probar conexión en ConfiguraciónController
En modules/configuracion/controller.py, implementa:

python
Copiar
Editar
def probar_conexion_db(self, server, database, user, password, port):
    """
    1. Intente conectarse a la base usando pyodbc.connect con la cadena DSN adecuada.
    2. Si la conexión es exitosa, retorne True.
    3. Si falla, capture la excepción y retorne False o lance ValueError(f"No se pudo conectar: {error}").
    """
    try:
        conn_string = f"DRIVER={{SQL Server}};SERVER={server},{port};DATABASE={database};UID={user};PWD={password}"
        conn = pyodbc.connect(conn_string, timeout=5)
        conn.close()
        return True
    except Exception as e:
        raise ValueError(f"No se pudo conectar: {e}")
En modules/configuracion/view.py, conecta el botón “Probar conexión” para que llame a este método y muestre QMessageBox apropiado según True/False.

shell
Copiar
Editar

### 6.2. Guardar y leer configuración desde BD
En modules/configuracion/model.py, implementa:

python
Copiar
Editar
def guardar_config(self, datos_config):
    """
    Inserta o actualiza la fila única en tabla 'configuraciones' con claves:
    theme, idioma, timezone, etc.
    """
    sql_exists = "SELECT COUNT(1) FROM configuraciones"
    count = self.db.select_one(sql_exists)[0]
    if count == 0:
        sql = "INSERT INTO configuraciones(theme, idioma, timezone) VALUES (?, ?, ?)"
        self.db.execute(sql, (datos_config['theme'], datos_config['idioma'], datos_config['timezone']))
    else:
        sql = "UPDATE configuraciones SET theme=?, idioma=?, timezone=?"
        self.db.execute(sql, (datos_config['theme'], datos_config['idioma'], datos_config['timezone']))
En modules/configuracion/controller.py, al iniciar la app, llame a model.obtener_config() y cargue los valores en core/config.py para aplicar el tema e idioma.

shell
Copiar
Editar

### 6.3. Gestión de usuarios y permisos
En modules/usuarios/controller.py, implementa:

crear_usuario(self, username, password, rol_id) que:

Valide que username no exista (SELECT COUNT(*) FROM usuarios WHERE username=?).

Hashee la contraseña (bcrypt) y guarde en usuarios(username, password_hash, rol_id).

Llamar a asignar_permisos_por_rol(rol_id) para llenar permisos_por_usuario.

Registrar auditoría “Usuario Admin creó al usuario {username} con rol {rol_id}”.

editar_permisos_usuario(self, user_id, nuevos_permisos_dict) que:

Actualice permisos_por_usuario según el dict.

Registrar auditoría “Usuario Admin actualizó permisos de {user_id}”.

Emitir señal para recargar el Sidebar (por ejemplo, EventBus.publish("PermisosActualizados", user_id)).

En modules/usuarios/view.py, cuando se modifiquen permisos, la UI del Sidebar recargue dinámicamente sin necesidad de reiniciar la app.

shell
Copiar
Editar

### 6.4. Tests para Configuración y Usuarios
Crea tests/usuarios/test_usuarios_model.py:

Fixture SQLite en memoria con tablas usuarios, roles, permisos_por_rol, permisos_por_usuario.

Prueba test_crear_usuario_exitoso que:

Llame crear_usuario("user1","P@ssw0rd", rol_id=2) y verifique:

En la tabla usuarios existe el username “user1” y password_hash no es vacío.

En permisos_por_usuario existan las filas heredadas de permisos_por_rol para rol_id=2.

Prueba test_crear_usuario_usuario_duplicado que:

Inserte manualmente “user2” y luego llame a crear_usuario("user2","abc",1) y espere ValueError("Usuario ya existe").

Prueba test_editar_permisos que:

Llame a editar_permisos_usuario(user_id, {'obras':{'ver':False,...}, ...}) y verifique que en permisos_por_usuario se actualicen correctamente.

Crea tests/configuracion/test_configuracion_controller.py:

Fixture SQLite en memoria con tabla configuraciones.

Prueba test_probar_conexion_correcta que:

Use credenciales válidas (puede mockear pyodbc.connect para devolver conexión simulada) y verifique que probar_conexion_db(...) retorne True.

Prueba test_probar_conexion_incorrecta que:

Mockee pyodbc.connect para lanzar excepción y verifique que probar_conexion_db(...) lance ValueError("No se pudo conectar: ...").

Prueba test_guardar_y_leer_config que:

Llame a guardar_config({'theme':'dark','idioma':'es','timezone':'America/Argentina/Buenos_Aires'}).

Verifique que obtener_config() retorne exactamente esos valores.

yaml
Copiar
Editar

---

## 7. Módulo “Contabilidad” (Facturas y Pagos)

### 7.1. Generar factura en ContabilidadModel
En modules/contabilidad/model.py, implementa:

python
Copiar
Editar
def generar_factura_por_pedido(self, id_pedido):
    """
    1. Consulte pedidos_por_obra y precios unitarios para el id_pedido.
    2. Calcule total = SUM(cantidad_recibida * precio_unitario).
    3. Inserte en facturas(id_pedido, fecha_emision=NOW(), total, estado='Pendiente') y recupere id_factura.
    4. Registrar auditoría “Usuario X generó factura {id_factura} para pedido {id_pedido}”.
    5. Retornar id_factura.
    """
    # Implementar con transacción timeout=30, retries=2
shell
Copiar
Editar

### 7.2. Registrar pago en ContabilidadModel
En modules/contabilidad/model.py, implementa:

python
Copiar
Editar
def registrar_pago(self, id_factura, monto, forma_pago, usuario):
    """
    1. Consulte la factura para obtener total y estado.
    2. Si estado != 'Pendiente', lance ValueError("Factura ya pagada" o similar).
    3. Si monto > total, lance ValueError("Monto excede total de la factura").
    4. Inserte en pagos(id_factura, monto, fecha_pago=NOW(), forma_pago).
    5. Si monto == total, actualice facturas.estado='Pagada'; si monto < total, actualice facturas.saldo_restante = total - monto.
    6. Registrar auditoría “Usuario X registró pago de {monto} a factura {id_factura}”.
    7. Retornar True.
    """
    # Implementar con transacción timeout=30, retries=2
shell
Copiar
Editar

### 7.3. UI y Controller de Contabilidad
En modules/contabilidad/controller.py y modules/contabilidad/view.py:

En el Controller, defina señales:

generar_factura_signal(id_pedido) que conecta a generar_factura_por_pedido.

registrar_pago_signal(id_factura, monto, forma_pago) que conecta a registrar_pago.

ver_balance_signal() que conecta a obtener_balance().

En el View:

Pestaña “Facturas Pendientes”:

QTableWidget que muestre facturas con estado “Pendiente” (columnas: ID, Pedido, Total, FechaEmisión).

Botón “Generar factura” que abra un diálogo con dropdown de pedidos “Recibidos sin factura” y emita generar_factura_signal.

Pestaña “Registrar Pago”:

Dropdown de facturas pendientes.

QDoubleSpinBox para monto.

Dropdown QComboBox para forma de pago (Efectivo, Transferencia, Cheque).

Botón “Registrar pago” que emita registrar_pago_signal.

Pestaña “Balance General”:

QLabel que muestre “Total pendiente: $X”, “Total pagado: $Y”, “Facturas pendientes: N”, “Facturas pagadas: M”.

(Opcional) Un FigureCanvas de matplotlib que dibuje un gráfico de barras con facturación mensual (datos obtenidos de obtener_balance()).

Cada acción que invoque un método del modelo debe capturar ValueError y mostrar QMessageBox.warning.

graphql
Copiar
Editar

### 7.4. Tests para ContabilidadModel y Controller
Crea tests/contabilidad/test_contabilidad_model.py:

Fixture SQLite en memoria con tablas: pedidos, pedidos_por_obra, facturas, pagos, productos (con precios unitarios).

Inserte un pedido con id_pedido=1 y entradas en pedidos_por_obra:

id_vidrio=1, cantidad_recibida=5, precio_unitario=200.

id_perfil=2, cantidad_recibida=10, precio_unitario=100.

Prueba test_generar_factura:

Llame a generar_factura_por_pedido(1) y verifique:

Se inserta factura con total = 5200 + 10100 = 2000.

Estado “Pendiente”.

Auditoría “Usuario X generó factura {id_factura} para pedido 1”.

Prueba test_registrar_pago_parcial:

Inserte una factura con total=2000, estado “Pendiente”.

Llame a registrar_pago(id_factura, monto=500, forma_pago="Efectivo", usuario="test").

Verifique que en pagos exista registro, en facturas saldo_restante=1500 y estado sigue “Pendiente”.

Verifique auditoría “Usuario test registró pago de 500 a factura {id_factura}”.

Prueba test_registrar_pago_total:

Inserte factura con total=2000, estado “Pendiente”.

Llame a registrar_pago(id_factura, monto=2000, forma_pago="Transferencia", usuario="test").

Verifique estado “Pagada” en facturas.

Verifique auditoría “Usuario test registró pago de 2000 a factura {id_factura}”.

Crea tests/contabilidad/test_contabilidad_controller.py:

Fixture con MockDBConnection en memoria con las mismas tablas.

Prueba test_generar_factura_con_permisos:

Simule usuario Admin con permiso “crear”, llame crear_factura(id_pedido=1) y verifique que se llamó a generar_factura_por_pedido y auditoría.

Prueba test_generar_factura_sin_permisos:

Usuario sin permiso “crear” espere ValueError("Permisos insuficientes").

Prueba test_registrar_pago_con_permisos:

Simule factura existente y usuario con permiso “crear”, llame registrar_pago(id_factura=1, monto=2000, forma_pago="Cheque") y verifique DB y auditoría.

Prueba test_registrar_pago_sin_permisos:

Usuario sin permiso “crear” espere ValueError("Permisos insuficientes").

yaml
Copiar
Editar

---

## 8. Módulo “Auditoría” (Historial y Exportación)

### 8.1. Filtrar auditorías en AuditoriaModel
En modules/auditoria/model.py, implementa:

python
Copiar
Editar
def contar_auditorias(self, fecha_desde=None, fecha_hasta=None, modulo=None, usuario=None):
    """
    Construya un SQL dinámico:
      SELECT COUNT(*) FROM auditorias_sistema WHERE 1=1
      (agregar AND fecha >= ? si fecha_desde dado)
      (AND fecha <= ? si fecha_hasta dado)
      (AND modulo = ? si modulo dado)
      (AND usuario = ? si usuario dado)
    Retorne el entero del COUNT.
    """

def listar_auditorias(self, fecha_desde=None, fecha_hasta=None, modulo=None, usuario=None, offset=0, limit=50):
    """
    Mismo WHERE que contar_auditorias, más:
      ORDER BY fecha DESC
      OFFSET ? ROWS FETCH NEXT ? ROWS ONLY
    Retorne lista de tuplas (usuario, modulo, accion, fecha).
    """
Usa consultas parametrizadas para evitar inyección SQL.

shell
Copiar
Editar

### 8.2. Exportar auditorías a Excel en AuditoriaController
En modules/auditoria/controller.py, implementa:

python
Copiar
Editar
def exportar_excel(self, filtros):
    """
    1. Llame a model.contar_auditorias con filtros para obtener total.
    2. Llame a model.listar_auditorias con offset=0, limit=total para obtener todas las filas.
    3. Convierta el resultado a pandas.DataFrame con columnas ["Usuario","Módulo","Acción","Fecha"].
    4. Genere nombre de archivo: f"exports/auditorias_{datetime.now():%Y%m%d_%H%M%S}.xlsx".
    5. Use df.to_excel(ruta) para guardar.
    6. Registrar auditoría “Usuario X exportó auditoría a Excel: <ruta>”.
    7. Retornar la ruta del archivo.
    """
shell
Copiar
Editar

### 8.3. UI de Auditoría en View y Controller
En modules/auditoria/view.py y modules/auditoria/controller.py:

En la Vista, diseñar:

Dos QDateEdit para “Desde” y “Hasta”.

QComboBox con opciones de “Todos” + lista de módulos (Obras, Inventario, etc.).

QLineEdit para “Usuario”.

Botón “Filtrar” que emita filtrar_auditorias_signal(dict_filtros, pagina=1).

QTableWidget con columnas [Usuario, Módulo, Acción, Fecha].

Botones “Anterior” y “Siguiente” con un QLabel “Página X de Y”.

Botón “Exportar a Excel” que emita exportar_excel_signal(dict_filtros).

En el Controller, conecte:

signal_filtrar_auditorias a filtrar_auditorias(filtros, pagina):

Calcule offset = (pagina - 1)* limit.

Llame a model.contar_auditorias(...) y model.listar_auditorias(..., offset, limit).

Llame a view.actualizar_tabla(registros, total, pagina).

signal_exportar_excel a exportar_excel(filtros), que obtenga la ruta del archivo y muestre QMessageBox.information(f"Exportado a: {ruta}").

Asegúrate de deshabilitar “Anterior” si pagina == 1 y “Siguiente” si offset + limit ≥ total.

shell
Copiar
Editar

### 8.4. Tests para AuditoríaModel y Controller
Crea tests/auditoria/test_auditoria_model.py:

Fixture SQLite en memoria con tabla auditorias_sistema.

Inserte varios registros con usuarios “admin”, “user1” en distintos módulos y fechas escalonadas.

Pruebe test_contar_sin_filtros que contar_auditorias() retorne el número total.

Pruebe test_contar_con_filtros que contar_auditorias(fecha_desde, fecha_hasta, modulo="Obras", usuario="admin") retorne la cuenta adecuada.

Pruebe test_listar_offset_limit que listar_auditorias(..., offset=0, limit=5) devuelva 5 filas ordenadas por fecha descendente.

Crea tests/auditoria/test_auditoria_controller.py:

Fixture MockDBConnection en memoria con datos idénticos.

Pruebe test_filtrar_auditorias que:

Llame filtrar_auditorias(filtros, pagina=2) y mockee view.actualizar_tabla para capturar sus argumentos.

Verifique que recibe (registros, total, pagina) correctos.

Pruebe test_exportar_excel que:

Llame exportar_excel(filtros), verifique que devuelve una ruta que existe en exports/.

Mockee view.mostrar_mensaje y verifique que se muestre “Exportado a: <ruta>”.

yaml
Copiar
Editar

---

## 9. Integración “Obras → Inventario → Pedidos → Contabilidad” (E2E)

### 9.1. Test E2E de flujo completo
Crea tests/e2e/test_flujo_completo.py usando pytest-qt que:

Inicie la aplicación principal (MainWindow) con qtbot y registre un usuario Admin en MockDBConnection.

Login como Admin.

Cree una obra “ObraPrueba” desde la UI:

Haga clic en el botón “Agregar Obra”, complete los campos (nombre, cliente, fecha med., fecha ent.), clic “Guardar”.

Verifique que en la tabla de Obras aparezca “ObraPrueba”.

Desde la pestaña “Inventario → Perfiles”:

Seleccione la obra “ObraPrueba”.

Elija un perfil (por ejemplo “Perfil1” con stock ≥ 10), ingrese cantidad=5 y clique “Reservar”.

Verifique que en la grilla “Perfiles por Obra” aparezca la fila con “Perfil1” y “5” unidades.

Vaya a “Compras → Pedidos”:

Seleccione “ObraPrueba” y clique “Generar pedido”.

En el diálogo, verifique que el listado muestre “Perfil1” con “Cantidad pendiente = 5”.

Clique “Confirmar pedido” y espere a que se cierre el dialog.

Verifique en la tabla “Pedidos” que exista un pedido con estado “Pendiente” y total estimado = 5 * (precio unitario).

En “Pedidos”, seleccione el pedido recién creado y clique “Recibir pedido”.

Verifique que cambie a estado “Recibido”.

Vaya a “Inventario → Perfiles” y confirme que el stock de “Perfil1” aumentó en 5.

Vaya a “Contabilidad”:

En “Facturas Pendientes”, clique “Generar factura” para el pedido generado.

Verifique que la factura aparezca en la lista con estado “Pendiente” y total correcto.

Clique “Registrar pago” para esa factura, ingrese monto igual al total, clic “Guardar”.

Verifique que la factura desaparezca de “Pendientes” y aparezca en “Pagadas”.

Vaya a “Auditoría”:

Aplique un filtro con módulo=”Obras” y usuario=“Admin” y asegúrese de que exista un registro “Creó obra …”.

Exporte a Excel y verifique que el archivo exista en exports/.

Al final, cierre la app.

yaml
Copiar
Editar

---

## 10. UI/UX, Accesibilidad y Estilos

### 10.1. Añadir tooltips y efectos de sombra
En cada View correspondiente (modules/obras/view.py, modules/inventario/view.py, etc.):

Para cada QLineEdit, QComboBox y QPushButton, llame a setToolTip("Descripción breve y clara").

Para los botones principales y tarjetas, aplique QGraphicsDropShadowEffect con:

python
Copiar
Editar
from PyQt6.QtWidgets import QGraphicsDropShadowEffect
from PyQt6.QtGui import QColor

sombra = QGraphicsDropShadowEffect(widget)
sombra.setBlurRadius(16)
sombra.setColor(QColor(37, 99, 235, 60))
sombra.setOffset(0, 4)
widget.setGraphicsEffect(sombra)
Aplica esto, por ejemplo, a los botones “Guardar”, “Reservar”, “Generar pedido”.

Eliminar cualquier setStyleSheet embebido en el código y asegurarse de que los estilos estén en resources/qss/theme_light.qss y theme_dark.qss.

shell
Copiar
Editar

### 10.2. Ajustar margenes y separación en Sidebar via QSS
En resources/qss/theme_light.qss y theme_dark.qss, agrega o revisa:

css
Copiar
Editar
QWidget#sidebar { background-color: #FFFFFF; }
QPushButton#sidebarBoton {
    margin: 4px 0;
    padding: 4px 8px;
    border: 1px solid #e3e3e3;
    border-radius: 8px;
    font-size: 12px;
    text-align: left;
}
QPushButton#sidebarBoton:hover { background-color: #e3f6fd; }
QPushButton#sidebarBoton:pressed { background-color: #d1f7e7; }
QPushButton#sidebarBotonLogs,
QPushButton#sidebarBotonAyuda { margin: 8px 0 4px 0; }
QPushButton#sidebarThemeToggle { margin: 8px 0; }
QLabel#sidebarUserLabel { margin: 8px 0 4px 0; font-size: 11px; color: #222; }
Asegúrate de que cada SidebarButton tenga setObjectName("sidebarBoton") para que las reglas apliquen.

yaml
Copiar
Editar

---

## 11. Scripts de Base de Datos y Migraciones

### 11.1. Consolidación en `estructura_tablas_mps.sql`
Abre scripts/estructura_tablas_mps.sql y verifica que contenga:

Sentencias CREATE TABLE para:

usuarios, roles, permisos_por_rol, permisos_por_usuario

obras, etapas_obras

inventario_perfiles, perfiles_por_obra, movimientos_stock

herrajes, herrajes_por_obra, movimientos_herrajes

vidrios, vidrios_por_obra, movimientos_vidrios

pedidos, pedidos_por_obra

facturas, pagos

auditorias_sistema

Columnas clave:

rowversion en obras.

stock_minimo en tablas de inventario (perfiles, herrajes, vidrios).

Tipos ENUM o VARCHAR(20) para estados (ej. 'Pendiente', 'Recibido', 'Pagada').

Índices y claves foráneas:

FK obras(id_cliente) → clientes(id_cliente) si existe tabla clientes.

FK perfiles_por_obra(id_perfil) → inventario_perfiles(id_perfil).

FK movimientos_stock(id_perfil) → inventario_perfiles(id_perfil).

Equivalentes para herrajes y vidrios.

FK pedidos(id_obra) → obras(id_obra).

FK pedidos_por_obra(id_pedido) → pedidos(id_pedido).

FK facturas(id_pedido) → pedidos(id_pedido).

FK pagos(id_factura) → facturas(id_factura).

FK auditorias_sistema(usuario_id) → usuarios(id_usuario) (o almacenar nombre directo).

Si faltan tablas o columnas, agrégalas aquí en orden lógico.

shell
Copiar
Editar

### 11.2. Script de bootstrap de roles y permisos
En scripts/bootstrap_roles_permisos.sql, asegúrate de que:

Inserta roles base:

Admin (con todos los permisos “ver/crear/editar/eliminar/aprobar” en todos los módulos).

Operario (solo permisos “ver” y “crear” en Inventario, Pedidos; “ver” en Obras).

Contador (permiso “crear” y “ver” en Contabilidad; “ver” en Pedidos, Obras).

Auditor (permiso “ver” en Auditoría).

Inserta permisos_por_rol correspondientes para cada módulo con las banderas booleanas.

Crea un usuario “admin” con rol_id=1 y contraseña hasheada (bcrypt) en usuarios.

Crea un usuario de prueba “demo” con rol “Operario”.

yaml
Copiar
Editar

---

## 12. Documentación y Checklist de Release

### 12.1. Actualizar README.md
Modifica el archivo README.md para que incluya:

Instrucciones de instalación:

Clonar el repositorio git clone ....

Crear entorno virtual e instalar dependencias pip install -r requirements.txt.

Variables de entorno obligatorias (en .env.example):

DB_SERVER, DB_PORT, DB_DATABASE, DB_USER, DB_PASSWORD, DEFAULT_THEME, DEBUG_MODE, LOG_LEVEL.

Cómo ejecutar migraciones:

cd scripts y sqlcmd -S <server> -i estructura_tablas_mps.sql (o equivalente para PostgreSQL).

Cómo ejecutar bootstrap de roles:

sqlcmd -S <server> -i bootstrap_roles_permisos.sql.

Cómo iniciar la app:

python main.py.

Cómo correr tests:

pytest --maxfail=1 --disable-warnings --cov=modules.

Cómo empacar la app con PyInstaller (opcional).

Notas de la versión 1.1.0 y próximos pasos.

shell
Copiar
Editar

### 12.2. Crear CHANGELOG.md
Crea un archivo CHANGELOG.md con el formato:

[1.1.0] - YYYY-MM-DD
Añadido
Alta, edición y bloqueo optimista (rowversion) en Obras.

Generación automática de la primera etapa de cada obra.

Módulo completo de Pedidos (generar/recibir/actualizar stock).

Inventario de Perfiles con reserva, devolución y ajustes.

Módulos de Herrajes y Vidrios con funcionalidad completa.

UI de Lista de Precios de Perfiles editable.

Gestión de usuarios y permisos con refresh dinámico del Sidebar.

Módulo de Contabilidad (facturas y pagos).

Módulo de Auditoría con filtrado, paginación y exportación a Excel.

Flujo E2E: Obras → Inventario → Pedidos → Contabilidad.

Tests unitarios, de integración y E2E (pytest-qt) para todos los módulos.

Interfaz mejorada con tooltips, sombras y accesibilidad.

Scripts SQL unificados en estructura_tablas_mps.sql.

Bootstrap de usuarios/roles en bootstrap_roles_permisos.sql.

Corregido
Eliminación de duplicados en el Sidebar y ajustes de QSS.

Bloqueo de tests de UI (pytest-qt) habilitados.

Varios bugs de validaciones de fechas, stock insuficiente y errores silenciosos.

Pendiente
Reportes automáticos por email.

Migración de datos legacy.

Empaquetado multiplataforma.

Documentación final de migración legacy.

yaml
Copiar
Editar

---

Cada uno de estos prompts está diseñado para que Copilot genere el código o los tests en el archivo y ubicación adecuados. Simplemente pégalos uno a uno en tu editor con Copilot habilitado, revisa la salida, ajusta nombres de variables según tu convención y repite hasta cubrir todos los puntos. Con eso tendrás la base lista para llevar la aplicación a producción. ¡Éxitos!




Tú dijiste:
dame los prompts para todas estas cosas


ChatGPT Plus

Pensó durante un par de segundos
1. Módulo “Obras”
1.1. Alta de obra con validaciones y auditoría
python
Copiar
Editar
# Prompt para Copilot:
En modules/obras/controller.py, dentro de la clase ObrasController, implementa el método:

def alta_obra(self, datos):
    """
    1. Reciba un dict con llaves: 'nombre', 'cliente_id', 'fecha_medicion' (YYYY-MM-DD), 'fecha_entrega' (YYYY-MM-DD).
    2. Valide:
       - 'nombre' y 'cliente_id' no estén vacíos.
       - fecha_entrega > fecha_medicion. Si falla, lance ValueError("Fecha de entrega debe ser posterior a la fecha de medición").
    3. Inserte la nueva obra en la tabla 'obras' dentro de una transacción con timeout=30 y retries=2. La tabla 'obras' debe tener columna 'rowversion' autoactualizada.
       - Recupere id_obra y rowversion recién generados.
    4. Genere automáticamente la primera etapa (por ejemplo, 'Fabricación') con fecha = fecha_medicion + 90 días y guárdela en la tabla 'etapas_obras'.
    5. Registre en auditorías_sistema: _registrar_evento_auditoria(usuario, "Obras", f"Creó obra {id_obra}").
    6. Retorne id_obra.
    """
    # (Copilot debe generar el código completo TLSQL, transacción, consultas parametrizadas, captura de errores y auditoría.)
1.2. Edición de obra con rowversion y manejo de conflictos
python
Copiar
Editar
# Prompt para Copilot:
En modules/obras/controller.py, dentro de la clase ObrasController, agrega:

def editar_obra(self, id_obra, datos, rowversion_orig):
    """
    1. Valide:
       - 'nombre' y 'cliente_id' no estén vacíos.
       - fecha_entrega > fecha_medicion. Si falla, lance ValueError("Fecha de entrega inválida").
    2. Dentro de una transacción (timeout=30, retries=2), ejecute:
       UPDATE obras
         SET nombre=?, cliente_id=?, fecha_medicion=?, fecha_entrega=?
         WHERE id_obra=? AND rowversion=?
       usando valores de datos y rowversion_orig.
    3. Si filas afectadas = 0, lance OptimisticLockError("Otro usuario modificó esta obra previamente").
    4. Si actualización exitosa, recupere nuevo rowversion y registre auditoría: _registrar_evento_auditoria(usuario, "Obras", f"Editó obra {id_obra}").
    5. Retorne el nuevo rowversion.
    """
    # (Copilot debe escribir la transacción, la consulta parametrizada, el chequeo de filas afectadas, la excepción OptimisticLockError y la auditoría.)
1.3. Test unitario para ObrasModel
csharp
Copiar
Editar
# Prompt para Copilot:
Crea el archivo tests/obras/test_obras_model.py con pytest y haz que:
1. Declare un fixture que inicialice una base SQLite en memoria con la tabla 'obras' (incluyendo 'rowversion' como BLOB o ROWVERSION).
2. Implemente test_listar_obras_vacia():
   - Llame a ObrasModel.listar_obras() y afirme que retorna lista vacía.
3. Implemente test_insertar_y_listar_obra():
   - Inserte manualmente vía SQL una fila en 'obras' con nombre='Prueba', cliente_id=1, fecha_medicion='2025-06-01', fecha_entrega='2025-07-01'.
   - Llame a listar_obras(), tome la fila devuelta y afirme que id_obra, nombre, cliente_id, fecha_medicion, fecha_entrega y rowversion no sean None ni vacíos.
4. Implemente test_editar_obra_conflicto_rowversion():
   - Inserte una obra vía SQL; obtenga id_obra y rowversion_orig.
   - Ejecute un UPDATE directo en la tabla para cambiar el rowversion (simulando edición concurrente).
   - Llame a ObrasModel.editar_obra(id_obra, nuevos_datos, rowversion_orig) y espere que lance OptimisticLockError.
5. Use asserts de pytest y cierre la conexión en cada prueba.
1.4. Test de integración para ObrasController
csharp
Copiar
Editar
# Prompt para Copilot:
Crea el archivo tests/obras/test_obras_controller_integracion.py con pytest y haz que:
1. Declare un fixture que inicialice SQLite en memoria con tablas 'obras' y 'auditorias_sistema'.
2. En test_alta_obra_exitoso():
   - Cree un dict datos = {'nombre':'Obra1','cliente_id':2,'fecha_medicion':'2025-06-01','fecha_entrega':'2025-07-01'}.
   - Instancie ObrasController con la conexión en memoria.
   - Llame a ctrl.alta_obra(datos) y capture id_obra.
   - Verifique que ObrasModel.listar_obras() retorne exactamente una fila con id_obra y nombre='Obra1'.
   - Verifique que en auditorias_sistema exista un registro con modulo='Obras' y accion="Creó obra {id_obra}".
3. En test_editar_obra_exitoso():
   - Inserte manualmente vía SQL una obra; obtenga id_obra y rowversion_orig.
   - Llame a ctrl.editar_obra(id_obra, datos_modificados, rowversion_orig) y obtenga nuevo_rowversion.
   - Verifique que listar_obras() retorne el nuevo nombre y que rowversion ≠ rowversion_orig.
   - Verifique que en auditorias_sistema exista un registro con accion="Editó obra {id_obra}".
4. En test_editar_obra_conflicto():
   - Inserte manualmente una obra; obtenga id_obra y rowversion_orig.
   - Haga un UPDATE directo para cambiar rowversion.
   - Llame a ctrl.editar_obra(id_obra, datos_modificados, rowversion_orig) y espere OptimisticLockError.
5. Use asserts de pytest y asegúrese de cerrar la conexión.
2. Módulo “Pedidos de Material”
2.1. Método generar_pedido_por_obra en PedidosModel
python
Copiar
Editar
# Prompt para Copilot:
En modules/pedidos/model.py, dentro de la clase PedidosModel, implementa:

def generar_pedido_por_obra(self, id_obra):
    """
    1. Consulte todas las reservas de perfiles, herrajes y vidrios asociadas a id_obra:
       - SELECT id_perfil, cantidad_reservada, p.stock_actual, p.precio_unitario
         FROM inventario_perfiles p
         JOIN perfiles_por_obra pp ON p.id_perfil = pp.id_perfil
         WHERE pp.id_obra = ?
       - SELECT id_herraje, cantidad_reservada, h.stock_actual, h.precio_unitario
         FROM herrajes h
         JOIN herrajes_por_obra hh ON h.id_herraje = hh.id_herraje
         WHERE hh.id_obra = ?
       - SELECT id_vidrio, cantidad_reservada, v.stock_actual, v.precio_unitario
         FROM vidrios v
         JOIN vidrios_por_obra vv ON v.id_vidrio = vv.id_vidrio
         WHERE vv.id_obra = ?
    2. Calcule faltante = cantidad_reservada – stock_actual; si faltante > 0, agrégalo a la lista de ítems a pedir.
    3. Calcule total_estimado = SUM(faltante * precio_unitario) sobre todos los ítems faltantes.
    4. Dentro de una transacción (timeout=30, retries=2), inserte en 'pedidos' (id_obra, fecha_emision=NOW(), estado='Pendiente', total_estimado).
       - Obtenga id_pedido recién insertado.
    5. Para cada ítem faltante, inserte en 'pedidos_por_obra':
       - Si es perfil: (id_pedido, id_obra, id_item=id_perfil, tipo='perfil', cantidad_requerida=faltante).
       - Análogo para herrajes y vidrios (use un campo 'tipo_item' o tabla separada según esquema existente).
    6. Registrar auditoría: _registrar_evento_auditoria(usuario, "Pedidos", f"Generó pedido {id_pedido} para obra {id_obra}").
    7. Retornar id_pedido.
    """
# Copilot debe generar la lógica completa de consultas, transacciones y auditoría.
2.2. Método recibir_pedido en PedidosModel
python
Copiar
Editar
# Prompt para Copilot:
En modules/pedidos/model.py, agrega:

def recibir_pedido(self, id_pedido):
    """
    1. Obtenga el registro de 'pedidos' donde id_pedido=?; si no existe o estado=='Recibido', lance ValueError("Pedido ya recibido o no existe").
    2. Si estado es 'Pendiente' o 'En Camino':
       a. Cambie estado a 'Recibido' en 'pedidos'.
    3. Para cada fila en 'pedidos_por_obra' con ese id_pedido:
       - Dependiendo de tipo_item ('perfil','herraje','vidrio'), aumente stock_actual en la tabla correspondiente:
         - UPDATE inventario_perfiles SET stock_actual = stock_actual + cantidad_recibida WHERE id_perfil = ?;
           INSERT INTO movimientos_stock(id_perfil, tipo_movimiento='Ingreso', cantidad=cantidad_recibida, fecha=NOW(), usuario).
         - Análogo para herrajes y vidrios (movimientos_herrajes, movimientos_vidrios).
    4. Registrar auditoría: _registrar_evento_auditoria(usuario, "Pedidos", f"Recibió pedido {id_pedido}").
    5. Retornar True.
    """
# Copilot debe escribir la lógica con transacción, consultas parametrizadas y auditoría.
2.3. Test unitario para PedidosModel
scss
Copiar
Editar
# Prompt para Copilot:
Crea tests/compras/test_pedidos_model.py con pytest que:
1. Declare un fixture que inicialice SQLite en memoria con tablas:
   - 'obras' (id_obra).
   - 'inventario_perfiles' (id_perfil, stock_actual, precio_unitario).
   - 'perfiles_por_obra' (id_obra, id_perfil, cantidad_reservada).
   - 'pedidos' (id_pedido, id_obra, estado, total_estimado).
   - 'pedidos_por_obra' (id_pedido, id_obra, id_item, tipo_item, cantidad_requerida).
   - 'movimientos_stock' (id_mov, id_perfil, tipo_movimiento, cantidad, fecha, usuario).
   - 'auditorias_sistema' (usuario, modulo, accion, fecha).
2. En test_generar_pedido():
   - Inserte:
     - Obra con id_obra=1.
     - Perfil con id_perfil=1, stock_actual=5, precio_unitario=100.
     - En perfiles_por_obra para obra=1 y perfil=1: cantidad_reservada=10.
   - Llame a generar_pedido_por_obra(1) y capture id_pedido.
   - Verifique que en 'pedidos' exista fila con id_pedido, estado='Pendiente', total_estimado=500.
   - Verifique que en 'pedidos_por_obra' exista fila con id_item=1, tipo_item='perfil', cantidad_requerida=5.
   - Verifique auditoría “Generó pedido {id_pedido} para obra 1”.
3. En test_recibir_pedido_exitoso():
   - Llame a recibir_pedido(id_pedido) y verifique:
     - 'pedidos.estado' pasó a 'Recibido'.
     - 'inventario_perfiles.stock_actual' pasó de 5 a 10.
     - En 'movimientos_stock' existe un registro con tipo_movimiento='Ingreso' y cantidad=5.
     - Auditoría “Recibió pedido {id_pedido}”.
4. En test_recibir_pedido_repetido():
   - Llame a recibir_pedido(id_pedido) dos veces y espere ValueError("Pedido ya recibido").
2.4. Test de integración para PedidosController
scss
Copiar
Editar
# Prompt para Copilot:
Crea tests/compras/test_pedidos_controller.py con pytest que:
1. Declare un fixture usando MockDBConnection o SQLite en memoria con mismas tablas que el modelo.
2. Cree un usuario “Admin” con permiso “crear” y “editar” en Pedidos.
3. En test_crear_pedido_con_permisos():
   - Llame a PedidosController.crear_pedido(obra_id=1) y verifique:
     - Que PedidosModel.generar_pedido_por_obra(1) haya sido invocado (mock o spy).
     - Que en auditorías exista “Generó pedido {id_pedido} para obra 1”.
4. En test_crear_pedido_sin_permisos():
   - Use un usuario con rol sin “crear” en Pedidos.
   - Llame a crear_pedido(1) y espere ValueError("Permisos insuficientes").
5. En test_recibir_pedido_con_permisos():
   - Inserte un pedido 'Pendiente' con id_pedido=1.
   - Llame a PedidosController.recibir_pedido(1) y verifique:
     - Que PedidosModel.recibir_pedido(1) haya incrementado stock y haya auditoría “Recibió pedido 1”.
6. En test_recibir_pedido_sin_permisos():
   - Use usuario sin permiso “editar” y espere ValueError("Permisos insuficientes").
3. Inventario de Perfiles
3.1. Métodos pendientes en InventarioModel
python
Copiar
Editar
# Prompt para Copilot:
En modules/inventario/model.py, dentro de la clase InventarioModel, agrega:

def reservar_perfil(self, usuario, id_obra, id_perfil, cantidad):
    """
    1. Obtenga stock_actual de inventario_perfiles WHERE id_perfil=?.
    2. Si cantidad > stock_actual, lance ValueError("Stock insuficiente").
    3. Reste stock_actual -= cantidad y actualice la fila en inventario_perfiles.
    4. Inserte o actualice en perfiles_por_obra(id_obra, id_perfil, cantidad_reservada, estado='Reservado').
    5. Inserte en movimientos_stock(id_perfil=id_perfil, tipo_movimiento='Egreso', cantidad=cantidad, fecha=NOW(), usuario=usuario).
    6. Registrar auditoría: _registrar_evento_auditoria(usuario, "Inventario", f"Reservó {cantidad} del perfil {id_perfil} para obra {id_obra}").
    7. Retorne True.
    """
    # Incluir transacción con timeout=30, retries=2 y consultas parametrizadas.

def devolver_perfil(self, usuario, id_obra, id_perfil, cantidad):
    """
    1. Obtenga stock_actual de inventario_perfiles WHERE id_perfil=?.
    2. Aumente stock_actual += cantidad y actualice inventario_perfiles.
    3. Actualice o elimine la fila en perfiles_por_obra para disminuir cantidad_reservada o cambiar estado.
    4. Inserte en movimientos_stock(tipo_movimiento='Ingreso', cantidad=cantidad, fecha=NOW(), usuario=usuario).
    5. Registrar auditoría: _registrar_evento_auditoria(usuario, "Inventario", f"Devolvió {cantidad} del perfil {id_perfil} de la obra {id_obra}").
    6. Retorne True.
    """
    # Con transacción y consultas parametrizadas.

def ajustar_stock_perfil(self, usuario, id_perfil, nueva_cantidad):
    """
    1. Si nueva_cantidad < 0, lance ValueError("Cantidad inválida").
    2. Obtenga stock_anterior de inventario_perfiles.
    3. Actualice inventario_perfiles.stock_actual = nueva_cantidad.
    4. Inserte en movimientos_stock(tipo_movimiento='Ajuste', cantidad=abs(nueva_cantidad - stock_anterior), fecha=NOW(), usuario=usuario).
    5. Registrar auditoría: _registrar_evento_auditoria(usuario, "Inventario", f"Ajustó stock del perfil {id_perfil} de {stock_anterior} a {nueva_cantidad}").
    6. Retorne True.
    """
    # Con transacción.
3.2. UI de Inventario (Perfiles) en View/Controller
python
Copiar
Editar
# Prompt para Copilot:
En modules/inventario/view.py y modules/inventario/controller.py, crea o completa:

# En InventarioController:
- Señales:
    reservar_perfil_signal = pyqtSignal(int, int, int)  # usuario, id_obra, id_perfil, cantidad
    devolver_perfil_signal = pyqtSignal(int, int, int)  # usuario, id_obra, id_perfil, cantidad
- Slots:
    def reservar_perfil(self, usuario, id_obra, id_perfil, cantidad):
        try:
            self.model.reservar_perfil(usuario, id_obra, id_perfil, cantidad)
            vista.mostrar_mensaje("Reserva exitosa")
        except ValueError as e:
            vista.mostrar_error(str(e))

    def devolver_perfil(self, usuario, id_obra, id_perfil, cantidad):
        try:
            self.model.devolver_perfil(usuario, id_obra, id_perfil, cantidad)
            vista.mostrar_mensaje("Devolución exitosa")
        except ValueError as e:
            vista.mostrar_error(str(e))

    def cargar_perfiles_por_obra(self, id_obra):
        filas = self.model.obtener_perfiles_por_obra(id_obra)
        vista.llenar_tabla_perfiles_por_obra(filas)

# En InventarioView:
- Cree un QComboBox cmb_obras para seleccionar la obra actual.
- Cree un QComboBox cmb_perfiles con autocompletar (datos de perfiles).
- Cree un QSpinBox spin_cantidad con rango 1 a stock_actual del perfil seleccionado.
- Cree dos QPushButton:
    btn_reservar = QPushButton("Reservar perfil")
    btn_reservar.clicked.connect(lambda: controller.reservar_perfil(current_user, cmb_obras.currentData(), cmb_perfiles.currentData(), spin_cantidad.value()))

    btn_devolver = QPushButton("Devolver perfil")
    btn_devolver.clicked.connect(lambda: controller.devolver_perfil(current_user, cmb_obras.currentData(), cmb_perfiles.currentData(), spin_cantidad.value()))

- Cree un QTableWidget tbl_perfiles_por_obra con columnas ["Perfil", "Cantidad Reservada", "Estado", "Fecha"].
- Al cambiar de obra en cmb_obras, llame a controller.cargar_perfiles_por_obra(id_obra).
- Cree una sección “Alertas de Stock” (QTableWidget) que liste perfiles donde stock_actual ≤ stock_minimo; coloree filas en rojo.
3.3. Test unitario para InventarioModel (Perfiles)
css
Copiar
Editar
# Prompt para Copilot:
Crea tests/inventario/test_inventario_perfiles_model.py con pytest que:
1. Declare un fixture que inicialice SQLite en memoria con tablas:
   - inventario_perfiles(id_perfil PK, nombre_perfil, stock_actual, stock_minimo, precio_unitario).
   - perfiles_por_obra(id_obra, id_perfil, cantidad_reservada, estado, fecha).
   - movimientos_stock(id_mov PK, id_perfil, tipo_movimiento, cantidad, fecha, usuario).
   - auditorias_sistema(usuario, modulo, accion, fecha).
2. Inserte manualmente:
   - Perfil con id_perfil=1, stock_actual=10, stock_minimo=3, precio_unitario=50.
   - Obra con id_obra=1.
3. Test test_reservar_perfil_exitoso():
   - Llame a InventarioModel.reservar_perfil("test", 1, 1, 5).
   - Verifique que inventario_perfiles.stock_actual = 5.
   - Verifique que perfiles_por_obra contenga fila (obra=1, perfil=1, cantidad_reservada=5, estado='Reservado').
   - Verifique movimientos_stock con tipo='Egreso', cantidad=5, usuario="test".
   - Verifique una auditoría “test reservó 5 del perfil 1 para obra 1”.
4. Test test_reservar_perfil_insuficiente():
   - Llame a reservar_perfil("test", 1, 1, 20) y espere ValueError("Stock insuficiente").
5. Test test_devolver_perfil_exitoso():
   - Primero llame a reservar_perfil("test", 1, 1, 5).
   - Luego llamar a InventarioModel.devolver_perfil("test", 1, 1, 3).
   - Verifique stock_actual = 8.
   - Verifique que perfiles_por_obra haya actualizado o eliminado la reserva.
   - Verifique movimientos_stock con tipo='Ingreso', cantidad=3.
   - Verifique auditoría “test devolvió 3 del perfil 1 de la obra 1”.
6. Test test_ajustar_stock_invalido():
   - Llame a InventarioModel.ajustar_stock_perfil("test", 1, -2) y espere ValueError("Cantidad inválida").
3.4. Test de integración para InventarioController (Perfiles)
css
Copiar
Editar
# Prompt para Copilot:
Crea tests/inventario/test_inventario_perfiles_controller.py con pytest que:
1. Declare un fixture usando MockDBConnection (SQLite en memoria) con tablas que el modelo usa.
2. Cree un usuario “admin” con permiso “crear” e “inventario” y déle el contexto al controller.
3. Test test_reservar_con_permisos():
   - Llame a controller.reservar_perfil("admin", obra_id=1, id_perfil=1, cantidad=5).
   - Verifique que inventario_perfiles.stock_actual haya disminuido en 5.
   - Verifique auditoría “admin reservó 5 del perfil 1 para obra 1”.
4. Test test_reservar_sin_permisos():
   - Cree un usuario “operario” sin permiso “crear” en inventario.
   - Llame a reservar_perfil y espere ValueError("Permisos insuficientes").
5. Test test_devolver_con_permisos():
   - Simule que ya existe una reserva de 5 unidades.
   - Llame a controller.devolver_perfil("admin", obra_id=1, id_perfil=1, cantidad=3).
   - Verifique que stock_actual aumentó en 3.
   - Verifique auditoría “admin devolvió 3 del perfil 1 de la obra 1”.
6. Test test_devolver_sin_permisos():
   - Usuario sin permiso “editar” en inventario; al llamar a devolver_perfil, espere ValueError("Permisos insuficientes").
4. Herrajes y Vidrios
4.1. Métodos en HerrajesModel
python
Copiar
Editar
# Prompt para Copilot:
En modules/herrajes/model.py, dentro de la clase HerrajesModel, agrega:

def reservar_herraje(self, usuario, id_obra, id_herraje, cantidad):
    """
    1. Obtenga stock_actual de 'herrajes' WHERE id_herraje=?.
    2. Si cantidad > stock_actual, lance ValueError("Stock insuficiente").
    3. Reste stock_actual -= cantidad y actualice 'herrajes'.
    4. Inserte/actualice en 'herrajes_por_obra'(id_obra, id_herraje, cantidad_reservada, estado='Reservado').
    5. Inserte en 'movimientos_herrajes'(id_herraje, tipo_movimiento='Egreso', cantidad, fecha=NOW(), usuario).
    6. Registrar auditoría: _registrar_evento_auditoria(usuario, "Herrajes", f"Reservó {cantidad} del herraje {id_herraje} para obra {id_obra}").
    7. Retorne True.
    """
    # Transacción con timeout=30 y retries=2.

def devolver_herraje(self, usuario, id_obra, id_herraje, cantidad):
    """
    1. Obtenga stock_actual de 'herrajes'.
    2. Aumente stock_actual += cantidad y actualice.
    3. Actualice o elimine fila en 'herrajes_por_obra'.
    4. Inserte en 'movimientos_herrajes'(tipo_movimiento='Ingreso', cantidad, fecha=NOW(), usuario).
    5. Registrar auditoría: _registrar_evento_auditoria(usuario, "Herrajes", f"Devolvió {cantidad} del herraje {id_herraje} de obra {id_obra}").
    6. Retorne True.
    """

def ajustar_stock_herraje(self, usuario, id_herraje, nueva_cantidad):
    """
    1. Si nueva_cantidad < 0, lance ValueError("Cantidad inválida").
    2. Obtenga stock_anterior de 'herrajes'.
    3. Actualice stock_actual = nueva_cantidad.
    4. Inserte en 'movimientos_herrajes'(tipo_movimiento='Ajuste', cantidad=abs(nueva_cantidad - stock_anterior), fecha=NOW(), usuario).
    5. Registrar auditoría: _registrar_evento_auditoria(usuario, "Herrajes", f"Ajustó stock del herraje {id_herraje} de {stock_anterior} a {nueva_cantidad}").
    6. Retorne True.
    """
    # Con transacciones.
4.2. Métodos en VidriosModel
python
Copiar
Editar
# Prompt para Copilot:
En modules/vidrios/model.py, dentro de la clase VidriosModel, agrega:

def reservar_vidrio(self, usuario, id_obra, id_vidrio, cantidad):
    """
    1. Obtenga stock_actual de 'vidrios'.
    2. Si cantidad > stock_actual, lance ValueError("Stock insuficiente").
    3. Reste stock_actual -= cantidad y actualice.
    4. Inserte/actualice en 'vidrios_por_obra'(id_obra, id_vidrio, cantidad_reservada, estado='Reservado').
    5. Inserte en 'movimientos_vidrios'(id_vidrio, tipo_movimiento='Egreso', cantidad, fecha=NOW(), usuario).
    6. Registrar auditoría: _registrar_evento_auditoria(usuario, "Vidrios", f"Reservó {cantidad} del vidrio {id_vidrio} para obra {id_obra}").
    7. Retorne True.
    """
    # Transacción con timeout=30, retries=2.

def devolver_vidrio(self, usuario, id_obra, id_vidrio, cantidad):
    """
    1. Aumente stock_actual += cantidad y actualice 'vidrios'.
    2. Actualice o elimine fila en 'vidrios_por_obra'.
    3. Inserte en 'movimientos_vidrios'(tipo_movimiento='Ingreso', cantidad, fecha=NOW(), usuario).
    4. Registrar auditoría: _registrar_evento_auditoria(usuario, "Vidrios", f"Devolvió {cantidad} del vidrio {id_vidrio} de obra {id_obra}").
    5. Retorne True.
    """

def ajustar_stock_vidrio(self, usuario, id_vidrio, nueva_cantidad):
    """
    1. Si nueva_cantidad < 0, lance ValueError("Cantidad inválida").
    2. Obtenga stock_anterior.
    3. Actualice stock_actual = nueva_cantidad.
    4. Inserte en 'movimientos_vidrios'(tipo_movimiento='Ajuste', cantidad=abs(nueva_cantidad - stock_anterior), fecha=NOW(), usuario).
    5. Registrar auditoría: _registrar_evento_auditoria(usuario, "Vidrios", f"Ajustó stock del vidrio {id_vidrio} de {stock_anterior} a {nueva_cantidad}").
    6. Retorne True.
    """
    # Con transacciones.
4.3. UI de Herrajes y Vidrios en View/Controller
css
Copiar
Editar
# Prompt para Copilot:
En modules/herrajes/view.py y modules/herrajes/controller.py:
1. En HerrajesController:
   - Señales:
       reservar_herraje_signal = pyqtSignal(int, int, int, int)  # usuario, id_obra, id_herraje, cantidad
       devolver_herraje_signal = pyqtSignal(int, int, int, int)
   - Slots:
       def reservar_herraje(self, usuario, id_obra, id_herraje, cantidad):
           try:
               self.model.reservar_herraje(usuario, id_obra, id_herraje, cantidad)
               view.mostrar_mensaje("Reserva de herraje exitosa")
           except ValueError as e:
               view.mostrar_error(str(e))

       def devolver_herraje(self, usuario, id_obra, id_herraje, cantidad):
           try:
               self.model.devolver_herraje(usuario, id_obra, id_herraje, cantidad)
               view.mostrar_mensaje("Devolución de herraje exitosa")
           except ValueError as e:
               view.mostrar_error(str(e))

       def cargar_herrajes_por_obra(self, id_obra):
           filas = self.model.obtener_herrajes_por_obra(id_obra)
           view.llenar_tabla_herrajes_por_obra(filas)

2. En HerrajesView:
   - QComboBox cmb_obras para seleccionar obra (id_obra).
   - QComboBox cmb_herrajes con autocompletar (id_herraje + nombre + stock_actual).
   - QSpinBox spin_cantidad con rango 1 a stock_actual.
   - QPushButton btn_reservar = QPushButton("Reservar herraje")
       btn_reservar.clicked.connect(lambda: controller.reservar_herraje(current_user, cmb_obras.currentData(), cmb_herrajes.currentData(), spin_cantidad.value()))
   - QPushButton btn_devolver = QPushButton("Devolver herraje")
       btn_devolver.clicked.connect(lambda: controller.devolver_herraje(current_user, cmb_obras.currentData(), cmb_herrajes.currentData(), spin_cantidad.value()))
   - QTableWidget tbl_herrajes_por_obra con columnas ["Herraje","Cantidad Reservada","Estado","Fecha"].
   - Cada vez que cmb_obras cambie, llamar a controller.cargar_herrajes_por_obra(id_obra).
   - Colorear en rojo filas si stock_actual ≤ stock_minimo.

En modules/vidrios/view.py y modules/vidrios/controller.py, haz lo mismo adaptado a vidrios.
4.4. Test unitario para HerrajesModel y VidriosModel
css
Copiar
Editar
# Prompt para Copilot:
Crea tests/herrajes/test_herrajes_model.py:
1. Fixture SQLite en memoria con tablas:
   - herrajes(id_herraje PK, nombre, stock_actual, stock_minimo, precio_unitario).
   - herrajes_por_obra(id_obra, id_herraje, cantidad_reservada, estado, fecha).
   - movimientos_herrajes(id_mov PK, id_herraje, tipo_movimiento, cantidad, fecha, usuario).
   - auditorias_sistema(usuario, modulo, accion, fecha).
2. Inserte manualmente:
   - Herraje con id_herraje=1, stock_actual=20, stock_minimo=5, precio_unitario=200.
   - Obra con id_obra=1.
3. Pruebas:
   test_reservar_herraje_exitoso():
     - Llame a reservar_herraje("test", 1, 1, 10).
     - Verifique stock_actual=10, herrajes_por_obra con cantidad_reservada=10, movimiento “Egreso”, auditoría “test reservó 10 del herraje 1 para obra 1”.
   test_reservar_herraje_insuficiente():
     - Llame a reservar_herraje("test", 1, 1, 30) y espere ValueError("Stock insuficiente").
   test_devolver_herraje_exitoso():
     - Primero reservar 10, luego llamar devolver_herraje("test",1,1,5).
     - Verifique stock_actual=15, movimiento “Ingreso”, auditoría “test devolvió 5 del herraje 1 de obra 1”.
   test_ajustar_stock_herraje_invalido():
     - Llame a ajustar_stock_herraje("test", 1, -3) y espere ValueError("Cantidad inválida").

Crea tests/vidrios/test_vidrios_model.py análogo, pero con tablas:
   - vidrios(id_vidrio PK, nombre, stock_actual, stock_minimo, precio_m2).
   - vidrios_por_obra, movimientos_vidrios, auditorias_sistema.
   - Usar id_vidrio=1, stock_actual=50, stock_minimo=10, precio_m2=300.
   - Pruebas de reservar, insuficiente, devolver y ajustar inválido.
4.5. Test de integración para HerrajesController y VidriosController
css
Copiar
Editar
# Prompt para Copilot:
Crea tests/herrajes/test_herrajes_controller.py:
1. Fixture usando MockDBConnection o SQLite en memoria con tablas de herrajes, reservas, movimientos y auditorías.
2. Cree un usuario “admin” con permiso “crear” y “editar” en herrajes.
3. test_reservar_herraje_con_permisos():
   - Llame a controller.asociar_herraje("admin", obra_id=1, id_herraje=1, cantidad=5).
   - Verifique que herrajes.stock_actual disminuyó en 5.
   - Verifique auditoría “admin reservó 5 del herraje 1 para obra 1”.
4. test_reservar_herraje_sin_permisos():
   - Usuario sin permiso “crear”; al llamar a asociar_herraje, espere ValueError("Permisos insuficientes").
5. test_devolver_herraje_con_permisos():
   - Simule reserva previa e invoque devolver_herraje("admin",1,1,3).
   - Verifique stock_actual aumentó en 3 y auditoría “admin devolvió 3 del herraje 1 de obra 1”.
6. test_devolver_herraje_sin_permisos():
   - Usuario sin permiso “editar”; espere ValueError("Permisos insuficientes").

Crea tests/vidrios/test_vidrios_controller.py con el mismo esquema para vidrios.
5. “Perfiles por obra” y “Lista de Precios”
5.1. Consultar perfiles por obra en InventarioModel
python
Copiar
Editar
# Prompt para Copilot:
En modules/inventario/model.py, dentro de InventarioModel, implementa:

def obtener_perfiles_por_obra(self, id_obra):
    """
    Retorna lista de tuplas (nombre_perfil, cantidad_reservada, estado, fecha)
    para todos los perfiles asociados a id_obra.
    SQL: 
      SELECT p.nombre_perfil, pp.cantidad_reservada, pp.estado, pp.fecha
      FROM perfiles_por_obra pp
      JOIN inventario_perfiles p ON pp.id_perfil = p.id_perfil
      WHERE pp.id_obra = ?
    """
    # Copilot genere la consulta parametrizada y retorne los resultados.
5.2. UI para “Perfiles por Obra” en InventarioView
ruby
Copiar
Editar
# Prompt para Copilot:
En modules/inventario/view.py y modules/inventario/controller.py:

# En InventarioController:
def cargar_perfiles_por_obra(self, id_obra):
    filas = self.model.obtener_perfiles_por_obra(id_obra)
    self.view.llenar_tabla_perfiles_por_obra(filas)

# En InventarioView:
- Cree una nueva pestaña o sección “Perfiles por Obra” con:
    QTableWidget tbl_perfiles_por_obra con columnas ["Perfil","Cantidad Reservada","Estado","Fecha"].
- Cuando el usuario seleccione una obra en cmb_obras, llame a controller.cargar_perfiles_por_obra(id_obra).
- Implemente llenar_tabla_perfiles_por_obra(filas) para poblar tbl_perfiles_por_obra con cada tupla.
5.3. Lista de precios de perfiles
python
Copiar
Editar
# Prompt para Copilot:
En modules/inventario/controller.py y modules/inventario/view.py:

# En InventarioController:
def obtener_lista_precios(self):
    """
    SQL:
      SELECT id_perfil, nombre_perfil, precio_unitario, stock_actual, stock_minimo
      FROM inventario_perfiles
    Retorna lista de tuplas.
    """
def actualizar_precio_perfil(self, usuario, id_perfil, nuevo_precio):
    """
    1. Si nuevo_precio < 0, lance ValueError("Precio inválido").
    2. Obtenga precio_anterior de inventario_perfiles WHERE id_perfil=?.
    3. Actualice inventario_perfiles SET precio_unitario=? WHERE id_perfil=?.
    4. Insertar auditoría: _registrar_evento_auditoria(usuario, "Inventario", f"Actualizó precio del perfil {id_perfil} de {precio_anterior} a {nuevo_precio}").
    5. Retorne True.
    """
# En InventarioView:
- Cree una pestaña “Precios” con QTableWidget tbl_precios con columnas ["Perfil","Precio unitario","Stock Actual","Stock Mínimo"].
- Cree botón “Editar precio” que, al hacer clic en una fila seleccionada, abra un QInputDialog para ingresar nuevo precio.
- Al confirmar, llame a controller.actualizar_precio_perfil(current_user, id_perfil, nuevo_precio) y luego recargue tbl_precios con obtener_lista_precios().
5.4. Tests para “Perfiles por Obra” y “Precios”
css
Copiar
Editar
# Prompt para Copilot:
Crea tests/inventario/test_perfiles_por_obra_model.py:
1. Fixture SQLite en memoria con tablas:
   - inventario_perfiles(id_perfil, nombre_perfil, precio_unitario, stock_actual, stock_minimo).
   - perfiles_por_obra(id_obra, id_perfil, cantidad_reservada, estado, fecha).
2. Inserte:
   - Perfil con id_perfil=1, nombre='P1', stock_actual=10, stock_minimo=3, precio_unitario=50.
   - Reserva en perfiles_por_obra para obra=1, id_perfil=1, cantidad_reservada=5, estado='Reservado', fecha=NOW().
3. Llame a InventarioModel.obtener_perfiles_por_obra(1) y verifique que retorne [('P1', 5, 'Reservado', <fecha>)].

Crea tests/inventario/test_precios_perfiles_controller.py:
1. Fixture MockDBConnection en memoria con inventario_perfiles y auditorias_sistema.
2. Test test_actualizar_precio_con_permisos():
   - Cree perfil con precio_unitario=100.
   - Llame a controller.actualizar_precio_perfil("admin", 1, 200) y verifique:
     - inventario_perfiles.precio_unitario = 200.
     - Auditoría “admin actualizó precio del perfil 1 de 100 a 200”.
3. Test test_actualizar_precio_sin_permisos():
   - Usuario sin permiso “editar” en inventario; al llamar a actualizar_precio_perfil, espere ValueError("Permisos insuficientes").
6. Módulo “Configuración” y “Usuarios/Roles”
6.1. Probar conexión en ConfiguraciónController
python
Copiar
Editar
# Prompt para Copilot:
En modules/configuracion/controller.py, agrega:

def probar_conexion_db(self, server, database, user, password, port):
    """
    1. Intente conectar usando pyodbc.connect con:
       DRIVER={SQL Server};SERVER={server},{port};DATABASE={database};UID={user};PWD={password}, timeout=5
    2. Si la conexión es exitosa, cierre la conexión y retorne True.
    3. Si falla, capture la excepción y lance ValueError(f"No se pudo conectar: {e}").
    """
    try:
        conn_str = f"DRIVER={{SQL Server}};SERVER={server},{port};DATABASE={database};UID={user};PWD={password}"
        conn = pyodbc.connect(conn_str, timeout=5)
        conn.close()
        return True
    except Exception as e:
        raise ValueError(f"No se pudo conectar: {e}")

# En modules/configuracion/view.py:
- Conecte el botón "Probar conexión" a un slot que llame a controller.probar_conexion_db(...) con los valores de los campos.
- Si retorna True, muestre QMessageBox.information("Conexión exitosa"); si lanza ValueError, muestre QMessageBox.critical("No se pudo conectar: <error>").
6.2. Guardar y leer configuración desde BD
python
Copiar
Editar
# Prompt para Copilot:
En modules/configuracion/model.py, implementa:

def guardar_config(self, datos_config):
    """
    1. Verifique si existe alguna fila en 'configuraciones' (SELECT COUNT(1)).
    2. Si count == 0, ejecute:
         INSERT INTO configuraciones(theme, idioma, timezone) VALUES (?, ?, ?)
       con valores de datos_config['theme'], datos_config['idioma'], datos_config['timezone'].
    3. Si count > 0, ejecute:
         UPDATE configuraciones SET theme=?, idioma=?, timezone=?
    4. Retorne True.
    """
def obtener_config(self):
    """
    1. SELECT theme, idioma, timezone FROM configuraciones LIMIT 1.
    2. Retorne un dict {'theme':..., 'idioma':..., 'timezone':...} o valores por defecto si no hay filas.
    """
6.3. Gestión de usuarios y permisos
python
Copiar
Editar
# Prompt para Copilot:
En modules/usuarios/controller.py, dentro de la clase UsuariosController, implementa:

def crear_usuario(self, username, password, rol_id):
    """
    1. Valide que username no exista (SELECT COUNT(*) FROM usuarios WHERE username=?); si existe, lance ValueError("Usuario ya existe").
    2. Hashee la contraseña con bcrypt y guárdela en password_hash.
    3. Inserte en usuarios(username, password_hash, rol_id).
    4. Llame a asignar_permisos_por_rol(rol_id, nuevo_user_id) para llenar permisos_por_usuario.
    5. Registrar auditoría: _registrar_evento_auditoria(current_user, "Usuarios", f"Creó usuario {username} con rol {rol_id}").
    6. Retorne nuevo_user_id.
    """

def editar_permisos_usuario(self, user_id, nuevos_permisos_dict):
    """
    1. Actualice la tabla permisos_por_usuario según nuevos_permisos_dict (modulo: {ver, crear, editar, eliminar, aprobar}).
    2. Registrar auditoría: _registrar_evento_auditoria(current_user, "Usuarios", f"Actualizó permisos de usuario {user_id}").
    3. Publique evento EventBus.publish("PermisosActualizados", user_id).
    4. Retorne True.
    """

# En modules/usuarios/view.py:
- Al guardar permisos para un usuario, llame a controller.editar_permisos_usuario(user_id, nuevos_permisos).
- Configure EventBus.subscribe("PermisosActualizados", lambda uid: sidebar.recargar(uid)) para que el Sidebar se refresque dinámicamente.
6.4. Tests para Configuración y Usuarios
csharp
Copiar
Editar
# Prompt para Copilot:
Crea tests/usuarios/test_usuarios_model.py con pytest que:
1. Fixture SQLite en memoria con tablas: 'usuarios', 'roles', 'permisos_por_rol', 'permisos_por_usuario', 'auditorias_sistema'.
2. Test test_crear_usuario_exitoso():
   - Llame a UsuariosController.crear_usuario("user1","P@ssw0rd", rol_id=2) y capture user_id.
   - Verifique en 'usuarios' que exista fila con username="user1" y password_hash no vacío.
   - Verifique en 'permisos_por_usuario' que existan filas heredadas de permisos_por_rol donde rol_id=2.
   - Verifique auditoría “Creó usuario user1 con rol 2”.
3. Test test_crear_usuario_duplicado():
   - Inserte manualmente usuario con username="user2".
   - Llame a crear_usuario("user2","abc",1) y espere ValueError("Usuario ya existe").
4. Test test_editar_permisos():
   - Cree usuario con rol 2.
   - Llame a editar_permisos_usuario(user_id, {'obras':{'ver':False,'crear':False,'editar':False,'eliminar':False,'aprobar':False}, ...}).
   - Verifique que en permisos_por_usuario las columnas para modulo 'obras' se hayan actualizado.
   - Verifique auditoría “Actualizó permisos de usuario {user_id}”.

Crea tests/configuracion/test_configuracion_controller.py con pytest que:
1. Fixture SQLite en memoria con tabla 'configuraciones'.
2. Test test_probar_conexion_correcta():
   - Mockee pyodbc.connect para simular conexión exitosa.
   - Llame a controller.probar_conexion_db("srv","db","user","pass","1433") y espere True.
3. Test test_probar_conexion_incorrecta():
   - Mockee pyodbc.connect para lanzar Exception("timeout").
   - Llame a probar_conexion_db y espere ValueError("No se pudo conectar: timeout").
4. Test test_guardar_y_obtener_config():
   - Llame a ConfiguracionController.guardar_config({'theme':'light','idioma':'es','timezone':'America/Argentina/Buenos_Aires'}).
   - Llame a ConfiguracionModel.obtener_config() y verifique que retorne el mismo dict.
7. Módulo “Contabilidad” (Facturas y Pagos)
7.1. Generar factura en ContabilidadModel
python
Copiar
Editar
# Prompt para Copilot:
En modules/contabilidad/model.py, dentro de la clase ContabilidadModel, agrega:

def generar_factura_por_pedido(self, usuario, id_pedido):
    """
    1. Consulte pedidos_por_obra para id_pedido, únalas a precios unitarios de perfiles, herrajes y vidrios:
       SELECT cantidad_recibida, precio_unitario FROM pedidos_por_obra ppo
       JOIN inventario_perfiles ip ON ppo.id_item = ip.id_perfil AND ppo.tipo_item='perfil'
       WHERE ppo.id_pedido = ?
       (y análogos para herrajes y vidrios).
    2. Calcule total = SUM(cantidad_recibida * precio_unitario) sobre todos los ítems.
    3. Dentro de una transacción (timeout=30, retries=2), inserte en facturas(id_pedido, fecha_emision=NOW(), total, estado='Pendiente').
       - Obtenga id_factura recién generado.
    4. Registrar auditoría: _registrar_evento_auditoria(usuario, "Contabilidad", f"Generó factura {id_factura} para pedido {id_pedido}").
    5. Retorne id_factura.
    """
    # Transacción y consultas parametrizadas.
7.2. Registrar pago en ContabilidadModel
python
Copiar
Editar
# Prompt para Copilot:
En modules/contabilidad/model.py, agrega:

def registrar_pago(self, usuario, id_factura, monto, forma_pago):
    """
    1. Consulte factura en facturas WHERE id_factura=?; retorne total y estado.
    2. Si estado != 'Pendiente', lance ValueError("Factura ya pagada").
    3. Si monto > total, lance ValueError("Monto excede total de la factura").
    4. Inserte en pagos(id_factura, monto, fecha_pago=NOW(), forma_pago).
    5. Si monto == total: UPDATE facturas SET estado='Pagada' WHERE id_factura=?.
       Si monto < total: UPDATE facturas SET saldo_restante = total - monto WHERE id_factura=?.
    6. Registrar auditoría: _registrar_evento_auditoria(usuario, "Contabilidad", f"Registró pago de {monto} a factura {id_factura}").
    7. Retorne True.
    """
    # Transacción con timeout=30, retries=2.
7.3. UI y Controller de Contabilidad
python
Copiar
Editar
# Prompt para Copilot:
En modules/contabilidad/controller.py y modules/contabilidad/view.py:

# En ContabilidadController:
- Señales:
    generar_factura_signal = pyqtSignal(int)  # id_pedido
    registrar_pago_signal = pyqtSignal(int, float, str)  # id_factura, monto, forma_pago
    ver_balance_signal = pyqtSignal()

- Slots:
    def crear_factura(self, usuario, id_pedido):
        try:
            id_factura = self.model.generar_factura_por_pedido(usuario, id_pedido)
            self.view.mostrar_mensaje(f"Factura {id_factura} creada exitosamente")
        except ValueError as e:
            self.view.mostrar_error(str(e))

    def registrar_pago(self, usuario, id_factura, monto, forma_pago):
        try:
            self.model.registrar_pago(usuario, id_factura, monto, forma_pago)
            self.view.mostrar_mensaje("Pago registrado exitosamente")
        except ValueError as e:
            self.view.mostrar_error(str(e))

    def cargar_balance(self):
        balance = self.model.obtener_balance()
        self.view.mostrar_balance(balance)

# En ContabilidadView:
- Pestaña “Facturas Pendientes”:
    QTableWidget tbl_facturas_pendientes con columnas ["ID","Pedido","Total","FechaEmisión"].
    QPushButton btn_generar_factura, al clic:
// abre QDialog con QComboBox pedidos_recibidos (solo pedidos con estado='Recibido' y sin factura)
    // al confirmar, emite generar_factura_signal(id_pedido).

- Pestaña “Registrar Pago”:
    QComboBox cmb_facturas_pendientes (id_factura + total).
    QDoubleSpinBox spin_monto (rango 0.01 a total).
    QComboBox cmb_forma_pago (["Efectivo","Transferencia","Cheque"]).
    QPushButton btn_registrar_pago que emite registrar_pago_signal(id_factura, spin_monto.value(), cmb_forma_pago.currentText()).

- Pestaña “Balance General”:
    QLabel lbl_total_pendiente, lbl_total_pagado, lbl_facturas_pendientes, lbl_facturas_pagadas.
    (Opcional) FigureCanvas con gráfico de barras mensual.
    Al cargar o al clic en un botón “Actualizar”, llamar a controller.cargar_balance() e invocar view.mostrar_balance(balance).
7.4. Tests para ContabilidadModel y Controller
csharp
Copiar
Editar
# Prompt para Copilot:
Crea tests/contabilidad/test_contabilidad_model.py con pytest que:
1. Fixture SQLite en memoria con tablas:
   - pedidos(id_pedido, id_obra, estado, total_estimado)
   - pedidos_por_obra(id_pedido, id_obra, id_item, tipo_item, cantidad_recibida)
   - inventario_perfiles(id_perfil, precio_unitario)
   - herrajes(id_herraje, precio_unitario)
   - vidrios(id_vidrio, precio_unitario)
   - facturas(id_factura, id_pedido, fecha_emision, total, estado, saldo_restante)
   - pagos(id_pago, id_factura, monto, fecha_pago, forma_pago)
   - auditorias_sistema(usuario, modulo, accion, fecha)

2. Inserte:
   - Pedido con id_pedido=1 y dos filas en pedidos_por_obra:
       (1,1,1,'perfil',5), (1,1,2,'vidrio',10)
   - En inventario_perfiles, id_perfil=1 con precio_unitario=100.
   - En vidrios, id_vidrio=2 con precio_unitario=200.
3. Test test_generar_factura():
   - Llame a generar_factura_por_pedido("test",1); capture id_factura.
   - Verifique que en 'facturas' exista fila con id_factura, total=5*100 + 10*200 = 2500, estado='Pendiente'.
   - Verifique auditoría “test generó factura {id_factura} para pedido 1”.

4. Test test_registrar_pago_parcial():
   - Inserte factura con id_factura=1, total=2500, estado='Pendiente'.
   - Llame a registrar_pago("test",1, 500, "Efectivo").
   - Verifique en 'pagos' registro con id_factura=1, monto=500.
   - Verifique en 'facturas' saldo_restante = 2000, estado sigue 'Pendiente'.
   - Verifique auditoría “test registró pago de 500 a factura 1”.

5. Test test_registrar_pago_total():
   - Inserte factura con id_factura=2, total=1000, estado='Pendiente'.
   - Llame a registrar_pago("test",2,1000,"Transferencia").
   - Verifique en 'pagos' y que factura 2 cambió a estado 'Pagada'.
   - Verifique auditoría “test registró pago de 1000 a factura 2”.

Crea tests/contabilidad/test_contabilidad_controller.py con pytest que:
1. Fixture MockDBConnection en memoria con las mismas tablas.
2. Test test_generar_factura_con_permisos():
   - Llame a ContabilidadController.crear_factura("admin",1) con pedido id_pedido=1 ya configurado en la DB.
   - Verifique que ContabilidadModel.generar_factura_por_pedido haya sido invocado y que auditoría “generó factura” exista.
3. Test test_generar_factura_sin_permisos():
   - Usuario sin permiso “crear” en Contabilidad; al llamar a crear_factura, espere ValueError("Permisos insuficientes").
4. Test test_registrar_pago_con_permisos():
   - Cree factura id_factura=1 con estado 'Pendiente'.
   - Llame a ContabilidadController.registrar_pago("admin",1,100,"Efectivo") y verifique cambio en DB y auditoría.
5. Test test_registrar_pago_sin_permisos():
   - Usuario sin permiso “crear”; al llamar a registrar_pago, espere ValueError("Permisos insuficientes").
8. Módulo “Auditoría” (Historial y Exportación)
8.1. Filtrar auditorías en AuditoriaModel
python
Copiar
Editar
# Prompt para Copilot:
En modules/auditoria/model.py, dentro de la clase AuditoriaModel, implementa:

def contar_auditorias(self, fecha_desde=None, fecha_hasta=None, modulo=None, usuario=None):
    """
    1. Construya SQL dinámico:
       SELECT COUNT(*) FROM auditorias_sistema WHERE 1=1
       - si fecha_desde dado: AND fecha >= ?
       - si fecha_hasta dado: AND fecha <= ?
       - si modulo dado: AND modulo = ?
       - si usuario dado: AND usuario = ?
    2. Ejecute con parámetros en el orden correcto y retorne el número.
    """

def listar_auditorias(self, fecha_desde=None, fecha_hasta=None, modulo=None, usuario=None, offset=0, limit=50):
    """
    1. Mismo WHERE que contar_auditorias.
    2. Append: ORDER BY fecha DESC OFFSET ? ROWS FETCH NEXT ? ROWS ONLY
    3. Ejecute con todos los parámetros (filtros + offset + limit) y retorne lista de tuplas (usuario, modulo, accion, fecha).
    """
    # Copilot debe generar la construcción condicional del WHERE y la consulta parametrizada.
8.2. Exportar auditorías a Excel en AuditoriaController
ruby
Copiar
Editar
# Prompt para Copilot:
En modules/auditoria/controller.py, dentro de la clase AuditoriaController, implementa:

def exportar_excel(self, usuario, filtros):
    """
    1. Llame a model.contar_auditorias(**filtros) para obtener total.
    2. Llame a model.listar_auditorias(**filtros, offset=0, limit=total) para obtener todas las filas.
    3. Convierta los resultados a pandas.DataFrame con columnas ["Usuario","Módulo","Acción","Fecha"].
    4. Genere nombre: f"exports/auditorias_{datetime.now():%Y%m%d_%H%M%S}.xlsx".
    5. Use df.to_excel(ruta, index=False).
    6. Registrar auditoría: _registrar_evento_auditoria(usuario, "Auditoría", f"Exportó auditoría a {ruta}").
    7. Retorne la ruta del archivo.
    """
    # Copilot debe importar pandas y datetime, construir DataFrame y guardar el archivo.
8.3. UI de Auditoría en View y Controller
python
Copiar
Editar
# Prompt para Copilot:
En modules/auditoria/view.py y modules/auditoria/controller.py:

# En AuditoriaController:
- Señales:
    filtrar_auditorias_signal = pyqtSignal(dict, int)  # filtros, pagina
    exportar_excel_signal = pyqtSignal(dict)          # filtros

- Slots:
    def filtrar_auditorias(self, usuario, filtros, pagina):
        limit = 50
        offset = (pagina - 1) * limit
        total = self.model.contar_auditorias(**filtros)
        registros = self.model.listar_auditorias(**filtros, offset=offset, limit=limit)
        self.view.actualizar_tabla(registros, total, pagina)

    def exportar_excel(self, usuario, filtros):
        ruta = self.model.exportar_excel(usuario, filtros)
        self.view.mostrar_mensaje(f"Exportado a: {ruta}")

# En AuditoriaView:
- Cree:
    QDateEdit date_desde, date_hasta.
    QComboBox cmb_modulo con opciones ["Todos","Obras","Inventario",...].
    QLineEdit edit_usuario.
    QPushButton btn_filtrar que emita filtrar_auditorias_signal(filtros_dict, pagina=1).
    QTableWidget tbl_auditoria con columnas ["Usuario","Módulo","Acción","Fecha"].
    QPushButton btn_anterior, btn_siguiente con un QLabel lbl_pagina = "Página 1 de X".
    QPushButton btn_exportar_excel que emita exportar_excel_signal(filtros_dict).
- En view.actualizar_tabla(registros, total, pagina):
    - Llene tbl_auditoria con la lista de registros.
    - Calcule total_paginas = ceil(total/50) y actualice lbl_pagina a f"Página {pagina} de {total_paginas}".
    - Habilite/deshabilite btn_anterior si pagina == 1; btn_siguiente si pagina >= total_paginas.
8.4. Tests para AuditoríaModel y Controller
csharp
Copiar
Editar
# Prompt para Copilot:
Crea tests/auditoria/test_auditoria_model.py con pytest que:
1. Fixture SQLite en memoria con tabla 'auditorias_sistema(usuario, modulo, accion, fecha)'.
2. Inserte varias filas con:
   - usuario='admin', modulo='Obras', accion='Creó obra 1', fechas escalonadas.
   - usuario='user1', modulo='Inventario', accion='Reservó perfil 1', otras fechas.
3. Pruebas:
   test_contar_sin_filtros():
     - Llame a contar_auditorias() y verifique que retorne el número total de filas.
   test_contar_con_filtros():
     - Llame a contar_auditorias(fecha_desde, fecha_hasta, modulo='Obras', usuario='admin') y verifique que retorne la cuenta adecuada.
   test_listar_offset_limit():
     - Llame a listar_auditorias(offset=0, limit=5) y verifique que retorne las primeras 5 filas ordenadas por fecha DESC.
   test_listar_con_filtro_usuario():
     - Llame a listar_auditorias(usuario='user1', offset=0, limit=10) y verifique que retorne sólo las filas de user1.

Crea tests/auditoria/test_auditoria_controller.py con pytest que:
1. Fixture MockDBConnection en memoria con datos idénticos.
2. Test test_filtrar_auditorias():
   - Llame a controlador.filtrar_auditorias("admin", filtros={'modulo':'Obras','usuario':'admin','fecha_desde':None,'fecha_hasta':None}, pagina=2).
   - Mockee view.actualizar_tabla para capturar (registros, total, pagina).
   - Verifique que pagina==2 y registros × total correspondan a offset = (2-1)*50.
3. Test test_exportar_excel():
   - Llame a controlador.exportar_excel("admin", mismas restricciones).
   - Verifique que retorna una ruta que existe en exports/ y que view.mostrar_mensaje haya sido invocado con "Exportado a: <ruta>".
9. Integración E2E “Obras → Inventario → Pedidos → Contabilidad”
9.1. Test E2E de flujo completo
css
Copiar
Editar
# Prompt para Copilot:
Crea tests/e2e/test_flujo_completo.py usando pytest-qt que:
1. Inicie la aplicación:
    app = QApplication([])
    main = MainWindow()  # importa desde main.py o módulo principal
    qtbot.addWidget(main)
    main.show()
2. Login como Admin:
    main.login_view.fixtures_crear_usuario("admin","P@ssw0rd", rol="Admin")
    main.login_view.txt_usuario.setText("admin")
    main.login_view.txt_contrasena.setText("P@ssw0rd")
    qtbot.mouseClick(main.login_view.btn_ingresar, Qt.LeftButton)
    qtbot.wait(200)
3. Crear obra “ObraPrueba”:
    qtbot.mouseClick(main.sidebar.btn_obras, Qt.LeftButton)
    qtbot.wait(200)
    qtbot.mouseClick(main.obras_view.btn_agregar_obra, Qt.LeftButton)
    main.obras_view.edit_nombre.setText("ObraPrueba")
    main.obras_view.cmb_cliente.setCurrentIndex(1)  # asume que hay al menos un cliente
    main.obras_view.date_medicion.setDate(QDate(2025,6,1))
    main.obras_view.date_entrega.setDate(QDate(2025,7,1))
    qtbot.mouseClick(main.obras_view.btn_guardar, Qt.LeftButton)
    qtbot.wait(200)
    # Verificar que en la grilla aparezca “ObraPrueba”
    assert any(item.text() == "ObraPrueba" for item in main.obras_view.tbl_obras.findItems("ObraPrueba", Qt.MatchExactly))

4. Reservar perfil para la obra:
    qtbot.mouseClick(main.sidebar.btn_inventario, Qt.LeftButton)
    qtbot.wait(200)
    main.inventario_view.cmb_obras.setCurrentIndex(main.inventario_view.cmb_obras.findData(obraid))
    qtbot.wait(100)
    main.inventario_view.cmb_perfiles.setCurrentIndex(1)  # asume perfil existente con stock ≥10
    main.inventario_view.spin_cantidad.setValue(5)
    qtbot.mouseClick(main.inventario_view.btn_reservar, Qt.LeftButton)
    qtbot.wait(200)
    # Verificar tbl_perfiles_por_obra contiene fila con perfil reservado
    assert any(item.text() == "Perfil1" for item in main.inventario_view.tbl_perfiles_por_obra.findItems("Perfil1", Qt.MatchExactly))

5. Generar y recibir pedido:
    qtbot.mouseClick(main.sidebar.btn_pedidos, Qt.LeftButton)
    qtbot.wait(200)
    main.pedidos_view.cmb_obras.setCurrentIndex(main.pedidos_view.cmb_obras.findData(obraid))
    qtbot.mouseClick(main.pedidos_view.btn_generar_pedido, Qt.LeftButton)
    qtbot.wait(200)
    # En el diálogo, verificar listado y confirmar
    qtbot.mouseClick(main.pedidos_view.dialog.cmb_perfiles.findText("Perfil1"), Qt.LeftButton)
    qtbot.mouseClick(main.pedidos_view.dialog.btn_confirmar, Qt.LeftButton)
    qtbot.wait(200)
    # Verificar tbl_pedidos contiene fila con estado "Pendiente"
    assert any(item.text() == "Pendiente" for item in main.pedidos_view.tbl_pedidos.findItems("Pendiente", Qt.MatchExactly))
    # Recibir pedido
    main.pedidos_view.tbl_pedidos.selectRow(0)
    qtbot.mouseClick(main.pedidos_view.btn_recibir, Qt.LeftButton)
    qtbot.wait(200)
    # Verificar que el estado cambió a "Recibido"
    assert any(item.text() == "Recibido" for item in main.pedidos_view.tbl_pedidos.findItems("Recibido", Qt.MatchExactly))
    # Verificar stock en Inventario aumentó
    qtbot.mouseClick(main.sidebar.btn_inventario, Qt.LeftButton)
    qtbot.wait(200)
    main.inventario_view.cmb_perfiles.setCurrentIndex(main.inventario_view.cmb_perfiles.findText("Perfil1"))
    qtbot.wait(100)
    # asume que main.inventario_view.lbl_stock muestra stock actual
    assert int(main.inventario_view.lbl_stock.text()) == stock_inicial + 5

6. Generar factura y registrar pago:
    qtbot.mouseClick(main.sidebar.btn_contabilidad, Qt.LeftButton)
    qtbot.wait(200)
    main.contabilidad_view.cmb_pedidos.setCurrentIndex(0)  # pedido recién recibido
    qtbot.mouseClick(main.contabilidad_view.btn_generar_factura, Qt.LeftButton)
    qtbot.wait(200)
    # Verificar tbl_facturas_pendientes contiene la nueva factura
    assert any(item.text() == str(pedido_id) for item in main.contabilidad_view.tbl_facturas_pendientes.findItems(str(pedido_id), Qt.MatchExactly))
    # Registrar pago total
    main.contabilidad_view.cmb_facturas.setCurrentIndex(0)
    main.contabilidad_view.spin_monto.setValue(total_factura)
    main.contabilidad_view.cmb_forma_pago.setCurrentText("Efectivo")
    qtbot.mouseClick(main.contabilidad_view.btn_registrar_pago, Qt.LeftButton)
    qtbot.wait(200)
    # Verificar factura desaparece de pendientes
    assert not any(item.text() == str(pedido_id) for item in main.contabilidad_view.tbl_facturas_pendientes.findItems(str(pedido_id), Qt.MatchExactly))

7. Verificar auditoría y exportación:
    qtbot.mouseClick(main.sidebar.btn_auditoria, Qt.LeftButton)
    qtbot.wait(200)
    main.auditoria_view.date_desde.setDate(QDate(2025,1,1))
    main.auditoria_view.date_hasta.setDate(QDate.currentDate())
    main.auditoria_view.cmb_modulo.setCurrentText("Obras")
    main.auditoria_view.edit_usuario.setText("admin")
    qtbot.mouseClick(main.auditoria_view.btn_filtrar, Qt.LeftButton)
    qtbot.wait(200)
    # Verifique que haya al menos un registro en la grilla
    assert main.auditoria_view.tbl_auditoria.rowCount() >= 1
    # Exportar a Excel
    qtbot.mouseClick(main.auditoria_view.btn_exportar_excel, Qt.LeftButton)
    qtbot.wait(200)
    # Check de que exista archivo en exports/ y mensaje emergente
    # (copilot puede usar os.listdir("exports") y QMessageBox spy)
8. Cierre la app al final:
    main.close()
    qtbot.wait(100)
10. UI/UX, Accesibilidad y Estilos
10.1. Agregar tooltips y sombras
css
Copiar
Editar
# Prompt para Copilot:
En cada módulo de vistas (por ejemplo, modules/obras/view.py, modules/inventario/view.py, etc.), recorra todos los widgets QLineEdit, QComboBox y QPushButton y haga:
widget.setToolTip("Breve descripción de la función del widget").

En los diálogos principales y botones clave, aplique QGraphicsDropShadowEffect:
from PyQt6.QtWidgets import QGraphicsDropShadowEffect
from PyQt6.QtGui import QColor

sombra = QGraphicsDropShadowEffect(widget)
sombra.setBlurRadius(16)
sombra.setColor(QColor(37, 99, 235, 60))
sombra.setOffset(0, 4)
widget.setGraphicsEffect(sombra)

Asegúrese de eliminar todo setStyleSheet embebido en el código y que todos los estilos residan en resources/qss/theme_light.qss y theme_dark.qss.
10.2. Ajustar márgenes y separación en Sidebar vía QSS
css
Copiar
Editar
# Prompt para Copilot:
En resources/qss/theme_light.qss y resources/qss/theme_dark.qss, agregue o verifique:

QWidget#sidebar {
    background-color: #FFFFFF;
}

QPushButton#sidebarBoton {
    margin: 4px 0;
    padding: 4px 8px;
    border: 1px solid #e3e3e3;
    border-radius: 8px;
    font-size: 12px;
    text-align: left;
}
QPushButton#sidebarBoton:hover {
    background-color: #e3f6fd;
}
QPushButton#sidebarBoton:pressed {
    background-color: #d1f7e7;
}

QPushButton#sidebarBotonLogs,
QPushButton#sidebarBotonAyuda {
    margin: 8px 0 4px 0;
}
QPushButton#sidebarThemeToggle {
    margin: 8px 0;
}
QLabel#sidebarUserLabel {
    margin: 8px 0 4px 0;
    font-size: 11px;
    color: #222;
}

Asegúrese de que cada SidebarButton en widgets/sidebar.py tenga setObjectName("sidebarBoton").
11. Scripts de Base de Datos y Migraciones
11.1. Consolidación en estructura_tablas_mps.sql
scss
Copiar
Editar
# Prompt para Copilot:
Abre scripts/estructura_tablas_mps.sql y asegúrate de incluir en orden cronológico:

-- Usuarios y Seguridad
CREATE TABLE roles (
    id_rol INT PRIMARY KEY IDENTITY(1,1),
    nombre VARCHAR(50) NOT NULL
);
CREATE TABLE usuarios (
    id_usuario INT PRIMARY KEY IDENTITY(1,1),
    username VARCHAR(50) NOT NULL UNIQUE,
    password_hash VARCHAR(256) NOT NULL,
    rol_id INT NOT NULL,
    FOREIGN KEY (rol_id) REFERENCES roles(id_rol)
);
CREATE TABLE permisos_por_rol (
    id_permiso INT PRIMARY KEY IDENTITY(1,1),
    rol_id INT NOT NULL,
    modulo VARCHAR(50) NOT NULL,
    ver BIT NOT NULL,
    crear BIT NOT NULL,
    editar BIT NOT NULL,
    eliminar BIT NOT NULL,
    aprobar BIT NOT NULL,
    FOREIGN KEY (rol_id) REFERENCES roles(id_rol)
);
CREATE TABLE permisos_por_usuario (
    id_usuario INT NOT NULL,
    modulo VARCHAR(50) NOT NULL,
    ver BIT NOT NULL,
    crear BIT NOT NULL,
    editar BIT NOT NULL,
    eliminar BIT NOT NULL,
    aprobar BIT NOT NULL,
    PRIMARY KEY (id_usuario, modulo),
    FOREIGN KEY (id_usuario) REFERENCES usuarios(id_usuario)
);

-- Obras con rowversion
CREATE TABLE obras (
    id_obra INT PRIMARY KEY IDENTITY(1,1),
    nombre VARCHAR(100) NOT NULL,
    cliente_id INT NOT NULL,
    fecha_medicion DATE NOT NULL,
    fecha_entrega DATE NOT NULL,
    rowversion ROWVERSION NOT NULL
);
CREATE TABLE etapas_obras (
    id_etapa INT PRIMARY KEY IDENTITY(1,1),
    id_obra INT NOT NULL,
    nombre_etapa VARCHAR(50) NOT NULL,
    fecha_programada DATE NOT NULL,
    FOREIGN KEY (id_obra) REFERENCES obras(id_obra)
);

-- Inventario Perfiles
CREATE TABLE inventario_perfiles (
    id_perfil INT PRIMARY KEY IDENTITY(1,1),
    nombre_perfil VARCHAR(100) NOT NULL,
    stock_actual INT NOT NULL,
    stock_minimo INT NOT NULL,
    precio_unitario DECIMAL(10,2) NOT NULL
);
CREATE TABLE perfiles_por_obra (
    id INT PRIMARY KEY IDENTITY(1,1),
    id_obra INT NOT NULL,
    id_perfil INT NOT NULL,
    cantidad_reservada INT NOT NULL,
    estado VARCHAR(20) NOT NULL,
    fecha DATETIME DEFAULT GETDATE(),
    FOREIGN KEY (id_obra) REFERENCES obras(id_obra),
    FOREIGN KEY (id_perfil) REFERENCES inventario_perfiles(id_perfil)
);
CREATE TABLE movimientos_stock (
    id_mov INT PRIMARY KEY IDENTITY(1,1),
    id_perfil INT NOT NULL,
    tipo_movimiento VARCHAR(20) NOT NULL,
    cantidad INT NOT NULL,
    fecha DATETIME DEFAULT GETDATE(),
    usuario VARCHAR(50) NOT NULL,
    FOREIGN KEY (id_perfil) REFERENCES inventario_perfiles(id_perfil)
);

-- Inventario Herrajes
CREATE TABLE herrajes (
    id_herraje INT PRIMARY KEY IDENTITY(1,1),
    nombre VARCHAR(100) NOT NULL,
    stock_actual INT NOT NULL,
    stock_minimo INT NOT NULL,
    precio_unitario DECIMAL(10,2) NOT NULL
);
CREATE TABLE herrajes_por_obra (
    id INT PRIMARY KEY IDENTITY(1,1),
    id_obra INT NOT NULL,
    id_herraje INT NOT NULL,
    cantidad_reservada INT NOT NULL,
    estado VARCHAR(20) NOT NULL,
    fecha DATETIME DEFAULT GETDATE(),
    FOREIGN KEY (id_obra) REFERENCES obras(id_obra),
    FOREIGN KEY (id_herraje) REFERENCES herrajes(id_herraje)
);
CREATE TABLE movimientos_herrajes (
    id_mov INT PRIMARY KEY IDENTITY(1,1),
    id_herraje INT NOT NULL,
    tipo_movimiento VARCHAR(20) NOT NULL,
    cantidad INT NOT NULL,
    fecha DATETIME DEFAULT GETDATE(),
    usuario VARCHAR(50) NOT NULL,
    FOREIGN KEY (id_herraje) REFERENCES herrajes(id_herraje)
);

-- Inventario Vidrios
CREATE TABLE vidrios (
    id_vidrio INT PRIMARY KEY IDENTITY(1,1),
    nombre VARCHAR(100) NOT NULL,
    stock_actual INT NOT NULL,
    stock_minimo INT NOT NULL,
    precio_m2 DECIMAL(10,2) NOT NULL
);
CREATE TABLE vidrios_por_obra (
    id INT PRIMARY KEY IDENTITY(1,1),
    id_obra INT NOT NULL,
    id_vidrio INT NOT NULL,
    cantidad_reservada INT NOT NULL,
    estado VARCHAR(20) NOT NULL,
    fecha DATETIME DEFAULT GETDATE(),
    FOREIGN KEY (id_obra) REFERENCES obras(id_obra),
    FOREIGN KEY (id_vidrio) REFERENCES vidrios(id_vidrio)
);
CREATE TABLE movimientos_vidrios (
    id_mov INT PRIMARY KEY IDENTITY(1,1),
    id_vidrio INT NOT NULL,
    tipo_movimiento VARCHAR(20) NOT NULL,
    cantidad INT NOT NULL,
    fecha DATETIME DEFAULT GETDATE(),
    usuario VARCHAR(50) NOT NULL,
    FOREIGN KEY (id_vidrio) REFERENCES vidrios(id_vidrio)
);

-- Pedidos y Compras
CREATE TABLE pedidos (
    id_pedido INT PRIMARY KEY IDENTITY(1,1),
    id_obra INT NOT NULL,
    fecha_emision DATETIME DEFAULT GETDATE(),
    estado VARCHAR(20) NOT NULL,
    total_estimado DECIMAL(12,2) NOT NULL,
    FOREIGN KEY (id_obra) REFERENCES obras(id_obra)
);
CREATE TABLE pedidos_por_obra (
    id INT PRIMARY KEY IDENTITY(1,1),
    id_pedido INT NOT NULL,
    id_obra INT NOT NULL,
    id_item INT NOT NULL,
    tipo_item VARCHAR(20) NOT NULL,
    cantidad_requerida INT NOT NULL,
    FOREIGN KEY (id_pedido) REFERENCES pedidos(id_pedido),
    FOREIGN KEY (id_obra) REFERENCES obras(id_obra)
);

-- Contabilidad
CREATE TABLE facturas (
    id_factura INT PRIMARY KEY IDENTITY(1,1),
    id_pedido INT NOT NULL,
    fecha_emision DATETIME DEFAULT GETDATE(),
    total DECIMAL(12,2) NOT NULL,
    estado VARCHAR(20) NOT NULL,
    saldo_restante DECIMAL(12,2) NULL,
    FOREIGN KEY (id_pedido) REFERENCES pedidos(id_pedido)
);
CREATE TABLE pagos (
    id_pago INT PRIMARY KEY IDENTITY(1,1),
    id_factura INT NOT NULL,
    monto DECIMAL(12,2) NOT NULL,
    fecha_pago DATETIME DEFAULT GETDATE(),
    forma_pago VARCHAR(20) NOT NULL,
    FOREIGN KEY (id_factura) REFERENCES facturas(id_factura)
);

-- Auditoría
CREATE TABLE auditorias_sistema (
    id INT PRIMARY KEY IDENTITY(1,1),
    usuario VARCHAR(50) NOT NULL,
    modulo VARCHAR(50) NOT NULL,
    accion VARCHAR(200) NOT NULL,
    fecha DATETIME DEFAULT GETDATE()
);

-- Indices y FK adicionales según convención
-- (Agrega índices en columnas utilizadas en WHERE y JOIN según necesidad)
11.2. Script de bootstrap de roles y permisos
sql
Copiar
Editar
# Prompt para Copilot:
En scripts/bootstrap_roles_permisos.sql, asegúrate de que incluya:

-- Insertar roles base
INSERT INTO roles(nombre) VALUES ('Admin'), ('Operario'), ('Contador'), ('Auditor');

-- Insertar permisos_por_rol para Admin (todos los módulos con ver=1, crear=1, editar=1, eliminar=1, aprobar=1)
DECLARE @modulos TABLE (nombre_modulo VARCHAR(50));
INSERT INTO @modulos VALUES 
  ('Obras'),('Inventario'),('Herrajes'),('Vidrios'),('Pedidos'),('Contabilidad'),
  ('Auditoría'),('Mantenimiento'),('Usuarios'),('Configuración');

INSERT INTO permisos_por_rol(rol_id, modulo, ver, crear, editar, eliminar, aprobar)
SELECT 1, nombre_modulo, 1, 1, 1, 1, 1 FROM @modulos;

-- Insertar permisos_por_rol para Operario (solo Inventario y Pedidos: ver=1, crear=1; Obras: ver=1; resto ver=0)
INSERT INTO permisos_por_rol(rol_id, modulo, ver, crear, editar, eliminar, aprobar) VALUES
(2,'Obras',1,0,0,0,0),
(2,'Inventario',1,1,0,0,0),
(2,'Herrajes',0,0,0,0,0),
(2,'Vidrios',0,0,0,0,0),
(2,'Pedidos',1,1,0,0,0),
(2,'Contabilidad',0,0,0,0,0),
(2,'Auditoría',0,0,0,0,0),
(2,'Mantenimiento',0,0,0,0,0),
(2,'Usuarios',0,0,0,0,0),
(2,'Configuración',0,0,0,0,0);

-- Insertar permisos_por_rol para Contador (Contabilidad: ver=1, crear=1; Pedidos y Obras: ver=1; resto 0)
INSERT INTO permisos_por_rol(rol_id, modulo, ver, crear, editar, eliminar, aprobar) VALUES
(3,'Obras',1,0,0,0,0),
(3,'Inventario',0,0,0,0,0),
(3,'Herrajes',0,0,0,0,0),
(3,'Vidrios',0,0,0,0,0),
(3,'Pedidos',1,0,0,0,0),
(3,'Contabilidad',1,1,0,0,0),
(3,'Auditoría',0,0,0,0,0),
(3,'Mantenimiento',0,0,0,0,0),
(3,'Usuarios',0,0,0,0,0),
(3,'Configuración',0,0,0,0,0);

-- Insertar permisos_por_rol para Auditor (solo Auditoría: ver=1)
INSERT INTO permisos_por_rol(rol_id, modulo, ver, crear, editar, eliminar, aprobar) VALUES
(4,'Obras',0,0,0,0,0),
(4,'Inventario',0,0,0,0,0),
(4,'Herrajes',0,0,0,0,0),
(4,'Vidrios',0,0,0,0,0),
(4,'Pedidos',0,0,0,0,0),
(4,'Contabilidad',0,0,0,0,0),
(4,'Auditoría',1,0,0,0,0),
(4,'Mantenimiento',0,0,0,0,0),
(4,'Usuarios',0,0,0,0,0),
(4,'Configuración',0,0,0,0,0);

-- Crear usuario admin con contraseña hasheada (ej: 'admin123')
INSERT INTO usuarios(username, password_hash, rol_id)
VALUES ('admin', '<HASH_BCRYPT_DE_ADMIN123>', 1);

-- Crear usuario demo con rol Operario
INSERT INTO usuarios(username, password_hash, rol_id)
VALUES ('demo', '<HASH_BCRYPT_DE_DEMO>', 2);
12. Documentación y Checklist de Release
12.1. Actualizar README.md
makefile
Copiar
Editar
# Prompt para Copilot:
Abre README.md y modifica o añade las siguientes secciones:

## Instalación
1. Clonar el repositorio:
   git clone https://github.com/nomdedev/stock.app.git
   cd stock.app
2. Crear y activar un entorno virtual:
   python -m venv venv
   source venv/bin/activate  # Linux/Mac
   venv\Scripts\activate     # Windows
3. Instalar dependencias:
   pip install -r requirements.txt

## Variables de Entorno
Copie .env.example a .env y complete:
DB_SERVER=<tu_servidor>
DB_PORT=<puerto>
DB_DATABASE=<nombre_bd>
DB_USER=<usuario>
DB_PASSWORD=<contraseña>
DEFAULT_THEME=light
DEBUG_MODE=False
LOG_LEVEL=INFO

## Migraciones y Estructura de BD
1. Ejecute en SQL Server (o su motor):
   cd scripts
   sqlcmd -S <server> -i estructura_tablas_mps.sql
2. Ejecute bootstrap de roles y permisos:
   sqlcmd -S <server> -i bootstrap_roles_permisos.sql

## Cómo usar la aplicación
Ejecute:
python main.py

## Tests
Para correr la suite completa:
pytest --maxfail=1 --disable-warnings --cov=modules

## Empaquetado (opcional)
Para generar ejecutable con PyInstaller:
pyinstaller --onefile main.py
12.2. Crear CHANGELOG.md
markdown
Copiar
Editar
# Prompt para Copilot:
Crea el archivo CHANGELOG.md con esta estructura:

## [1.1.0] - YYYY-MM-DD
### Añadido
- Alta, edición y bloqueo optimista (rowversion) en Obras.
- Generación automática de la primera etapa de cada obra.
- Funcionalidad completa de Pedidos (generar, recibir, actualizar stock en inventario).
- Inventario de Perfiles con métodos de reserva, devolución y ajustes.
- Nuevo módulo de Herrajes y módulo de Vidrios con reserva y devolución.
- UI de “Lista de Precios” de Perfiles editable.
- Gestión de Usuarios y Permisos con recarga dinámica del Sidebar.
- Módulo Contabilidad (generar factura, registrar pago, balance general).
- Módulo Auditoría con filtrado, paginación y exportación a Excel.
- Flujo E2E completo: Obras → Inventario → Pedidos → Contabilidad.
- Tests unitarios, de integración y E2E (pytest-qt) para todos los módulos.
- Interfaz mejorada con tooltips, sombras (QGraphicsDropShadowEffect) y accesibilidad.
- Scripts SQL unificados en scripts/estructura_tablas_mps.sql.
- Bootstrap de usuarios/roles en scripts/bootstrap_roles_permisos.sql.

### Corregido
- Eliminación de duplicados en el Sidebar y ajustes de QSS para márgenes y separación.
- Habilitación de tests de UI (pytest-qt) en pipeline de CI.
- Validaciones de fechas, stock insuficiente y errores silenciosos en varios módulos.

### Pendiente
- Reportes automáticos vía email (implementación futura).
- Herramienta de migración de datos legacy.
- Empaquetado multiplataforma (Windows, Mac, Linux).
- Documentación final de migración legacy y plan de rollback.
