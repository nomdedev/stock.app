# --- CHECKLIST DETALLADO PARA PASAR A PRODUCCIÓN (actualizado 2025-06-04) ---

## 1. UI/UX, SIDEBAR Y CONSISTENCIA VISUAL
- [x] Corregir el test del sidebar: asegurar que los botones extra (Configuración, Logs, Ayuda) usen exactamente el mismo QIcon que en los tests y no se dupliquen.
- [x] Validar que todos los botones del sidebar tengan icono válido y accesible (incluyendo Usuarios, Configuración, Logs, Ayuda, etc.).
- [x] Sidebar: el indicador online/offline debe cambiar dinámicamente según el estado real de la DB (test automatizado y validación manual).
- [x] Sidebar: el switch de tema debe funcionar, animar y persistir la preferencia (test automatizado y validación manual).
- [x] Sidebar: no debe haber módulos duplicados ni botones sin icono.
- [x] Sidebar: cumplir espaciado, padding, tamaño y estilos según QSS global (verificar con test visual y checklist de estándares).
- [x] Sidebar: accesibilidad, todos los botones deben tener accessibleName y/o toolTip descriptivo.
- [x] Todas las tablas (Vidrios, Producción, Obras, Inventario, etc.) deben tener headers y celdas visualmente consistentes, usando solo QSS global (test visual automatizado).
- [x] Validar que no quedan estilos embebidos en ningún módulo (solo QSS global y helpers).
- [x] Validar que todos los headers de tablas tienen el objectName correcto y el QSS esperado.
- [x] Validar que los cambios de columnas visibles en tablas persisten y no rompen el layout.
- [x] Validar que el feedback visual (mensajes de error, éxito, advertencia, info) usa color y emoji correcto en todos los módulos.
- [x] Validar que todos los botones principales sean solo ícono, salvo justificación documentada.
- [x] Validar que todos los layouts principales usan QVBoxLayout/QHBoxLayout con setContentsMargins y setSpacing según estándar.

## 2. PERMISOS Y SEGURIDAD
- [x] Validar robustez de login y feedback visual ante errores de clave, usuario o permisos.
- [x] Validar que la función crear_usuarios_iniciales asigne permisos completos a admin y mínimos a prueba.
- [x] Validar integración de permisos en el sidebar y main_window (solo módulos permitidos).
- [x] Revisar y corregir la lógica de obtención de módulos permitidos para cada usuario (admin debe ver todos).
- [x] Listar todos los módulos disponibles y mostrar qué permisos tiene cada usuario (especialmente admin).
- [x] Validar que Sidebar y controladores solo permiten acciones si permisos[modulo][accion] == True.
- [x] Validar en cada controlador que se rechace la acción si falta permiso (decoradores y lógica robusta).
- [x] Escribir y ejecutar tests unitarios de permisos (tests/test_permissions.py):
    - Sidebar no muestra módulos sin permiso_ver.
    - Controladores arrogan error si no hay permiso (p. ej. permiso_eliminar).

## 3. INTEGRACIÓN Y FLUJOS ENTRE MÓDULOS
- [x] Validar integración en tiempo real entre módulos (Obras, Inventario, Vidrios): que toda obra/pedido se refleje sin recargar la app.
- [x] Validar que la señal obra_agregada actualiza Inventario y Vidrios en tiempo real.
- [x] Validar feedback visual y consistencia de datos en todos los módulos tras operaciones cruzadas.
- [x] Documentar y soportar flujos alternativos (devolución de material, reasignación de vidrios, cierre anticipado de obra).

## 4. TABLAS, DATOS Y PERSONALIZACIÓN
- [x] Optimizar carga y paginación de tablas para grandes volúmenes de datos.
- [x] Permitir personalización de columnas y filtros en tablas de obras, pedidos y vidrios según usuario.
- [x] Validar que los cambios de columnas visibles persisten correctamente.
- [x] Visualizar el estado de cada ítem de pedido: entregado, pendiente, en espera de compra, etc.
- [x] Validaciones visuales (colores, íconos) para advertir si el stock es insuficiente antes de guardar el pedido.
- [x] Mostrar en la tabla de pedido de material: cantidad solicitada, stock disponible y cantidad faltante de cada ítem.

## 5. TESTS CRÍTICOS Y AUTOMATIZACIÓN
- [x] Ejecutar y validar todos los tests críticos listados en este checklist (sidebar, permisos, feedback, headers, accesibilidad, modo offline, etc.).
- [x] Agregar tests automáticos para edge cases: obra sin stock, pedido parcial, error de conexión, permisos insuficientes, etc.
- [x] Validar cobertura de tests en todos los módulos críticos (UI, controladores, modelos, integración).
- [x] Validar que los tests de integración y UI cubren los flujos principales y alternativos.

## 6. BACKEND, MODELOS Y AUDITORÍA
- [x] Validar que todos los scripts SQL de scripts/db/ cubren la creación y migración de tablas principales.
- [x] Validar que core/database.py soporta timeout y retries en transacciones.
- [x] Validar que los modelos usan begin_transaction(), commit(), rollback() donde corresponde.
- [x] Validar que la auditoría registra todas las acciones relevantes (alta, edición, entrega, cancelación) con fecha, usuario y detalle.
- [x] Validar unicidad de email y seguridad de contraseña en Usuarios.
- [x] Permitir desactivar usuarios y cambiar contraseñas.
- [x] Integrar pestaña de permisos por rol en la UI de Usuarios.

## 7. INFRAESTRUCTURA Y DEPENDENCIAS
- [x] Limpiar y validar requirements.txt (eliminar dependencias no usadas, fijar versiones, solo PyQt6).
- [x] Validar que el archivo .env.example incluye todas las claves necesarias y que .env está en .gitignore.
- [x] Validar que core/config.py carga correctamente las variables de entorno.
- [x] Probar en un entorno limpio: pip install -r requirements.txt y validar imports.
- [x] Validar que los scripts SQL funcionan en un servidor limpio.
- [x] Añadir endpoint /metrics con prometheus_client en main.py y documentar su uso.

## 8. DOCUMENTACIÓN Y ORGANIZACIÓN
- [x] Actualizar README y docs para reflejar la estructura, flujos y estándares actuales.
- [x] Centralizar documentación y crear índice en docs/README.md.
- [ ] Convertir este checklist en issues de GitHub o tareas formales.
- [x] Organizar tests y fixtures en carpetas por módulo.
- [x] Documentar cualquier excepción visual o de permisos en docs/estandares_visuales.md y estandares_seguridad.md.

# --- FIN DEL CHECKLIST DETALLADO PARA PRODUCCIÓN ---

# (Mantener este bloque al inicio del archivo y marcar cada punto a medida que se completa)

# COSAS POR HACER PARA PRODUCCIÓN (actualizado 2025-06-04)

## CRÍTICO: UI, SIDEBAR, ICONOS, CONSISTENCIA VISUAL Y TESTS
- [x] Sidebar moderno: solo muestra módulos permitidos según permisos del usuario.
- [x] Sidebar: todos los íconos se muestran correctamente (sin faltantes ni duplicados).
- [x] Sidebar: el indicador online/offline cambia dinámicamente según el estado real de la DB.
- [x] Sidebar: el switch de tema funciona y persiste la preferencia.
- [x] Consistencia visual: test visual automatizado para verificar que todas las tablas usan el mismo estilo de header y celdas.
- [x] Consistencia visual: test que no hay headers con color incorrecto (azul/celeste antiguo) en ningún módulo.
- [x] Vidrios/Producción: test de integración que verifica que los headers de las tablas tienen el objectName correcto y el QSS esperado.
- [x] Vidrios/Producción: test de que los cambios de columnas visibles persisten y no rompen el layout.
- [x] Modo offline: test de que activar/desactivar modo offline no cierra la app y realmente cambia el estado en la base/configuración.
- [x] Modo offline: test de que la app funciona correctamente en modo offline (sin DB).
- [x] Accesibilidad: test de que todos los botones y labels tienen accessibleName y accessibleDescription donde corresponde.
- [x] Feedback visual: test de que los mensajes de error, éxito, advertencia e info se muestran con el color y emoji correcto.
- [x] Permisos: test de que un usuario sin permisos no puede ver ni acceder a módulos restringidos desde el sidebar.

## INTEGRACIÓN Y FLUJOS CRÍTICOS
- [x] Validar integración en tiempo real entre módulos (Obras, Inventario, Vidrios): que toda obra/pedido se refleje sin recargar la app.
- [x] Validar robustez de login y feedback visual ante errores de clave, usuario o permisos.
- [x] Validar integración de permisos en el sidebar y main_window.
- [x] Revisar y corregir la lógica de obtención de módulos permitidos para cada usuario (admin debe ver todos).
- [x] Validar modelo y vista de Inventario, Obras, Vidrios: feedback visual, robustez de queries y manejo de errores.
- [x] Integración con pedidos y obras: reflejar cambios en tiempo real.
- [x] Permitir edición y cancelación de pedidos antes de ser procesados, con registro de cambios en la auditoría.
- [ ] Mejorar el SplashScreen: que desaparezca solo cuando la interfaz principal esté completamente cargada y lista.
- [ ] Validar visualmente que todos los módulos usan solo los QSS globales (themes/light.qss y themes/dark.qss) y que no quedan estilos embebidos.
- [ ] Ajustar los QSS globales si se detectan inconsistencias visuales tras la migración.
- [ ] Migrar cualquier estilo embebido o credencial que aún quede en otros módulos no revisados.
- [ ] Validar que el feedback visual y logging funcionen según los estándares en todos los módulos.

## USUARIOS Y PERMISOS
- [ ] Validar que la función `crear_usuarios_iniciales` asigne permisos completos a admin y permisos mínimos a prueba.
- [x] Listar todos los módulos disponibles y mostrar qué permisos tiene cada usuario (especialmente admin).
- [ ] Mejorar feedback visual y accesibilidad en login_view.
- [ ] Tests: robustecer tests de login, permisos y feedback visual.

## INVENTARIO, OBRAS, PEDIDOS, VIDRIOS
- [ ] Validar modelo y vista: feedback visual, robustez de queries y manejo de errores.
- [ ] Integración con pedidos y obras: reflejar cambios en tiempo real.
- [ ] Mostrar en la tabla de pedido de material: cantidad solicitada, stock disponible y cantidad faltante de cada ítem.
- [ ] Visualizar el estado de cada ítem de pedido: entregado, pendiente, en espera de compra, etc.
- [ ] Tests: robustecer tests de integración y UI.
- [ ] Corregir los tests de estándares y validación listados en el bloque anterior.

## MEJORAS DE LAYOUT Y ACCESIBILIDAD
- [x] Unificar todos los botones de acción en cada módulo en un QHBoxLayout, alineados horizontalmente, con espaciado 16px y addStretch() a la izquierda.
- [x] Sidebar: verificar que los botones cumplen el estándar visual y de espaciado (8px vertical entre botones, padding 10px horizontal).
- [x] Todos los botones principales deben ser solo ícono, sin texto visible, salvo justificación documentada.
- [x] Usar siempre el helper estilizar_boton_icono para tamaño, color y sombra uniforme.
- [x] El espaciado entre botones debe ser de 16px (o el definido en el estándar).
- [x] Si algún módulo requiere una excepción (botón con texto, disposición vertical, etc.), debe documentarse en el código y en docs/estandares_visuales.md.
- [x] Verificar que todos los layouts principales usen QVBoxLayout con setContentsMargins(24, 20, 24, 20) y setSpacing(16).

## TESTS AUTOMÁTICOS Y COBERTURA
- [ ] Crear tests unitarios y de integración para cada módulo.
- [ ] Usar mocks para la base de datos en local.
- [ ] Integrar pytest en CI.
- [ ] Mover datos de prueba a tests/fixtures/.

## SEGURIDAD Y CONFIGURACIÓN
- [ ] Implementar core/config.py que lea variables desde .env usando python-dotenv.
- [ ] Eliminar credenciales hard-coded.
- [ ] Documentar en el README la necesidad de .env local.
- [ ] Confirmar que core/config.py carga correctamente las variables de entorno.
- [ ] Limpiar y validar requirements.txt: eliminar dependencias no usadas, incluir versiones fijas, probar en entorno limpio.

## OTROS PENDIENTES Y MEJORAS
- [ ] Proveer dashboard/resumen visual con KPIs: obras activas, pedidos pendientes, stock crítico, etc.
- [ ] Automatizar reportes periódicos (por email o descarga) para responsables de obra, compras y stock.
- [ ] Agregar opción de exportar historial de pedidos a Excel/PDF.
- [ ] Permitir comentarios u observaciones en cada pedido para trazabilidad.
- [ ] Notificar al usuario (visual o por email) cuando el material esté disponible o el pedido haya sido procesado.
- [ ] Validaciones visuales (colores, íconos) para advertir si el stock es insuficiente antes de guardar el pedido.
- [ ] Mejorar navegación entre obras y pedidos: ir de un pedido a la obra asociada y viceversa con un clic.
- [ ] Registrar en la auditoría cada acción relevante (alta, edición, entrega, cancelación) con fecha, usuario y detalle.
- [ ] Revisar periódicamente la experiencia de usuario y el rendimiento en flujos con muchas obras o pedidos simultáneos.

# Mantener este checklist actualizado y marcar los tests implementados y validados.


1. Módulo “Obras”
1.1. Alta de obra con validaciones y auditoría
markdown
Copiar
Editar
Escribe el método `alta_obra(self, datos)` dentro de `ObrasController` (archivo modules/obras/controller.py) que:
1. Reciba un diccionario con llaves: “nombre”, “cliente_id”, “fecha_medicion” (YYYY-MM-DD) y “fecha_entrega” (YYYY-MM-DD).
2. En el backend (sin acceder directamente al QDialog), valide que “nombre” y “cliente_id” no estén vacíos, y que `fecha_entrega > fecha_medicion`. 
   - Si alguna validación falla, lance `ValueError("Mensaje claro del error")`.
3. Inserte la nueva obra en la tabla `obras` dentro de una transacción con timeout=30 y retries=2. 
   - La tabla debe tener columna `rowversion` que se genere automáticamente. 
   - Después de insertar, recupere el `id_obra` y el `rowversion` generado.
4. Genere automáticamente la primera etapa (por ejemplo, “Fabricación”) con fecha “fecha_medicion + 90 días” y guárdala en la tabla `etapas_obras` (o donde corresponda). 
5. Registre un evento en `auditorias_sistema` usando el helper `_registrar_evento_auditoria(usuario, "Obras", f"Creó obra {id_obra}")`.
6. Retorne el `id_obra` recién creado.
Guarda este fragmento en modules/obras/controller.py, dentro de la clase ObrasController.
1.2. Edición de obra con rowversion y captura de conflictos
java
Copiar
Editar
Implementa el método `editar_obra(self, id_obra, datos, rowversion_orig)` en `modules/obras/controller.py` que:
1. Revise que los campos “nombre”, “cliente_id”, “fecha_medicion” y “fecha_entrega” cumplan las mismas validaciones que en alta (no vacíos y fecha_entrega > fecha_medicion).
   - Si falla, lance `ValueError("Mensaje del error")`.
2. Dentro de una transacción (timeout=30, retries=2), ejecute:
   ```sql
   UPDATE obras
   SET nombre = ?, cliente_id = ?, fecha_medicion = ?, fecha_entrega = ?
   WHERE id_obra = ? AND rowversion = ?
usando los valores de datos y rowversion_orig.
3. Si el número de filas afectadas es 0, lance OptimisticLockError("Otro usuario actualizó esta obra previamente").
4. Si la actualización fue exitosa, obtenga el nuevo rowversion y registre auditoría:
_registrar_evento_auditoria(usuario, "Obras", f"Editó obra {id_obra}").
5. Retorne el nuevo rowversion.
Añade este método en la clase ObrasController, y asegúrate de importar o definir OptimisticLockError.

shell
Copiar
Editar

### 1.3. Tests unitarios para ObrasModel
Crea un archivo tests/obras/test_obras_model.py con pytest que:

Use un fixture que cree una base SQLite en memoria con la tabla obras (incluyendo la columna rowversion) y un método ObrasModel que conecte a esa base.

Escriba una prueba test_listar_obras_vacia que invoque listar_obras() y compruebe que retorne lista vacía.

Escriba una prueba test_insertar_y_listar_obra que inserte directamente via SQL una fila en obras (con nombre="Prueba", cliente_id=1, fechas válidas) y luego llame a listar_obras() y verifique que la fila encontrada tenga todos los campos correctos, incluido rowversion.

Escriba una prueba test_editar_obra_conflicto_rowversion que:

Inserte una fila, obtenga id_obra y rowversion_orig.

Actualice manualmente la fila para cambiar su rowversion (simulando edición concurrente).

Llame a editar_obra(id_obra, datos_modificados, rowversion_orig) y espere que lance OptimisticLockError.

Usa asserts de pytest y asegúrate de cerrar la conexión al final de cada prueba.

shell
Copiar
Editar

### 1.4. Test de integración para ObrasController
Crea un archivo tests/obras/test_obras_controller_integracion.py con pytest que:

Use un fixture para inicializar una base SQLite en memoria y registrar la tabla obras y la tabla de auditoría (auditorias_sistema).

Importe ObrasController y ObrasModel.

Prueba test_alta_obra_exitoso que:

Cree datos válidos ({"nombre":"Obra1","cliente_id":2,"fecha_medicion":"2025-06-01","fecha_entrega":"2025-07-01"}).

Llame a alta_obra(datos) y reciba un id_obra.

Verifique que ObrasModel.listar_obras() retorne exactamente una fila con id_obra, nombre “Obra1” y un rowversion no nulo.

Verifique que en auditorias_sistema exista un registro con módulo “Obras” y acción “Creó obra {id_obra}”.

Prueba test_editar_obra_exitoso que:

Inserte manualmente una obra con SQL y obtenga id_obra y rowversion_orig.

Llame a editar_obra(id_obra, datos_modificados, rowversion_orig) con datos_modificados cambiando el nombre.

Verifique que listar_obras() devuelva la obra con el nombre actualizado y nuevo rowversion.

Verifique que en auditoría exista un registro “Editó obra {id_obra}”.

Prueba test_editar_obra_conflicto que:

Inserte una obra, obtenga id_obra y rowversion_orig.

Actualice la fila directamente por SQL para cambiar rowversion.

Llame a editar_obra(id_obra, datos, rowversion_orig) y espere OptimisticLockError.

yaml
Copiar
Editar

---

## 2. Módulo “Pedidos de Material”

### 2.1. Método `generar_pedido_por_obra` en PedidosModel
En el archivo modules/pedidos/model.py, implementa el método:

python
Copiar
Editar
def generar_pedido_por_obra(self, id_obra):
    """
    1. Consulte todas las reservas de perfiles, herrajes y vidrios para id_obra:
       - SELECT id_perfil, cantidad_reservada, stock_actual FROM inventario_perfiles JOIN perfiles_por_obra ON …
       - SELECT id_herraje, cantidad_reservada, stock_actual FROM herrajes JOIN herrajes_por_obra ON …
       - SELECT id_vidrio, cantidad_reservada, stock_actual FROM vidrios JOIN vidrios_por_obra ON …
    2. Para cada ítem, calcule faltante = cantidad_reservada - stock_actual (si es > 0).
    3. Si faltante > 0, agrégalo a la lista de ítems a pedir.
    4. Inserte un nuevo registro en `pedidos` con campos: (fecha_emision=NOW(), estado='Pendiente', id_obra, total_estimado = SUM(faltante * precio_unitario aproximado por ítem)).
    5. Obtenga el `id_pedido` recién insertado.
    6. Para cada ítem faltante, inserte en `pedidos_por_obra(id_pedido, id_obra, id_item, cantidad_requerida=faltante)` (separando por tipo: perfil, herraje o vidrio).
    7. Registrar en `auditorias_sistema` (“Usuario X generó pedido {id_pedido} para obra {id_obra}”).
    8. Retornar `id_pedido`.
Use transacciones con timeout=30 y retries=2.  
2.2. Método recibir_pedido en PedidosModel
csharp
Copiar
Editar
En `modules/pedidos/model.py`, implementa:
```python
def recibir_pedido(self, id_pedido):
    """
    1. Consulte si el pedido existe y su estado es 'Pendiente' o 'En Camino'; si estado es 'Recibido', lanzar ValueError("Pedido ya recibido").
    2. Cambie estado de pedido a 'Recibido'.
    3. Para cada fila en pedidos_por_obra asociada a id_pedido:
       a. Dependiendo del tipo (perfil, herraje o vidrio), actualice la tabla de inventario correspondiente sumando cantidad_recibida a stock_actual.
       b. Inserte un registro en movimientos_stock (o movimientos_herrajes/movimientos_vidrios) con tipo 'Ingreso' y fecha=NOW().
    4. Registrar auditoría (“Usuario X confirmó recepción del pedido {id_pedido}”).
    5. Retornar True.
Use transacción con timeout=30 y retries=2.
2.3. Test unitario para PedidosModel
markdown
Copiar
Editar
Crea `tests/compras/test_pedidos_model.py` con pytest que:
1. Use un fixture para SQLite en memoria que cree tablas `obras`, `inventario_perfiles`, `perfiles_por_obra`, `movimientos_stock`, `pedidos`, `pedidos_por_obra`.
2. Inserte manualmente:
   - Una obra con id_obra=1.
   - Un perfil con id_perfil=1, stock_actual=5, precio_unitario=100.
   - En `perfiles_por_obra` para id_obra=1 y id_perfil=1, cantidad_reservada=10.
3. Llame a `generar_pedido_por_obra(1)` y verifique:
   - Retorna un id_pedido > 0.
   - En `pedidos` exista fila con estado='Pendiente' y total_estimado = (10 - 5) * 100 = 500.
   - En `pedidos_por_obra` exista fila con id_item=1, cantidad_requerida=5.
4. Llame a `recibir_pedido(id_pedido)` y verifique:
   - `pedidos.estado` para id_pedido ahora es 'Recibido'.
   - `inventario_perfiles.stock_actual` pasó de 5 a 10 (sumó las 5 unidades recibidas).
   - Existe un registro en `movimientos_stock` con tipo='Ingreso' y cantidad=5.
5. Llamar nuevamente `recibir_pedido(id_pedido)` y verificar que lance `ValueError("Pedido ya recibido")`.
2.4. Test de integración para PedidosController
perl
Copiar
Editar
Crea `tests/compras/test_pedidos_controller.py` con pytest que:
1. Use un MockDBConnection o SQLite en memoria para simular las tablas necesarias (obras, inventario_perfiles, perfiles_por_obra, pedidos, pedidos_por_obra, movimientos_stock, auditorias_sistema).
2. Simule un usuario con rol “Admin” (tiene permiso “crear” y “editar” en pedidos).
3. Prueba `test_crear_pedido_con_permisos` que:
   - Llame a `crear_pedido(1)` en PedidosController (obra_id=1) y verifique que internamente llame a `PedidosModel.generar_pedido_por_obra(1)`.
   - Verifique que en auditoría haya registro “Usuario Admin generó pedido X para obra 1”.
4. Prueba `test_crear_pedido_sin_permisos` que:
   - Use un usuario con rol “Operario” (sin permiso “crear” en pedidos).
   - Llame a `crear_pedido(1)` y espere `ValueError("Permisos insuficientes")`.
5. Prueba `test_recibir_pedido_con_permisos` que:
   - Inserte un pedido “Pendiente” (con id_pedido simulado) en la base, y llame `recibir_pedido(id_pedido)` desde el controlador.
   - Verifique que se actualice stock en inventario y exista auditoría “Usuario Admin confirmó recepción del pedido {id_pedido}”.
6. Prueba `test_recibir_pedido_sin_permisos` que:
   - Use un usuario sin permiso “editar” y espere `ValueError("Permisos insuficientes")`.
3. Inventario de Perfiles
3.1. Métodos pendientes en InventarioModel
markdown
Copiar
Editar
En `modules/inventario/model.py`, implementa:
1. `def reservar_perfil(self, id_obra, id_perfil, cantidad):`
   - Si `cantidad > stock_actual` en `inventario_perfiles`, lance `ValueError("Stock insuficiente")`.
   - Reste `stock_actual -= cantidad` y actualice la fila en `inventario_perfiles`.
   - Inserte o actualice en `perfiles_por_obra(id_obra, id_perfil, cantidad_reservada, estado='Reservado')`.
   - Inserte en `movimientos_stock(id_perfil=id_perfil, tipo_movimiento='Egreso', cantidad=cantidad, fecha=NOW(), usuario)`.
   - Registrar auditoría “Usuario X reservó {cantidad} del perfil {id_perfil} para obra {id_obra}”.
   - Retornar True.
2. `def devolver_perfil(self, id_obra, id_perfil, cantidad):`
   - Aumente en `stock_actual += cantidad` la tabla `inventario_perfiles`.
   - Actualice o elimine la fila en `perfiles_por_obra` (disminuyendo `cantidad_reservada` o marcando `estado='Liberado'`).
   - Inserte en `movimientos_stock(tipo_movimiento='Ingreso', cantidad=cantidad, fecha=NOW(), usuario)`.
   - Registrar auditoría “Usuario X devolvió {cantidad} del perfil {id_perfil} de la obra {id_obra}”.
   - Retornar True.
3. `def ajustar_stock_perfil(self, id_perfil, nueva_cantidad, usuario):`
   - Si `nueva_cantidad < 0`, lance `ValueError("Cantidad inválida")`.
   - Obtenga `stock_anterior` de `inventario_perfiles`.
   - Actualice `stock_actual = nueva_cantidad`.
   - Inserte en `movimientos_stock` un registro con tipo “Ajuste” y cantidad = abs(nueva_cantidad – stock_anterior), fecha=NOW(), usuario.
   - Registrar auditoría “Usuario X ajustó stock del perfil {id_perfil} de {stock_anterior} a {nueva_cantidad}”.
   - Retornar True.
Usa transacciones con timeout=30 y retries=2 en cada método.
3.2. UI de Inventario (Perfiles) en InventarioController e InventarioView
markdown
Copiar
Editar
Crea o completa `modules/inventario/view.py` y `modules/inventario/controller.py` para:
1. En `InventarioController`, agregar señales y slots:
   - `reservar_perfil_signal(id_obra, id_perfil, cantidad)` conectado a `reservar_perfil`.
   - `devolver_perfil_signal(id_obra, id_perfil, cantidad)` conectado a `devolver_perfil`.
2. El método `reservar_perfil(self, id_obra, id_perfil, cantidad)` invoque `InventarioModel.reservar_perfil` y capture ValueError para mostrar `QMessageBox.warning`.
3. Similar para `devolver_perfil`.
4. En `InventarioView`, diseñar un formulario:
   - `QComboBox` con todos los perfiles (`self.cmb_perfiles.addItems(…)`), cargados desde el modelo.
   - `QSpinBox` para cantidad (rango 1-`stock_actual`).
   - Botón “Reservar perfil” que emita `reservar_perfil_signal`.
   - Botón “Devolver perfil” que emita `devolver_perfil_signal`.
   - Una `QTableWidget` para “Perfiles por Obra” que muestre [NombrePerfil, CantidadReservada, Estado, Fecha].
   - Una sección “Alertas de Stock” que liste en rojo los perfiles con `stock_actual ≤ stock_minimo`.
5. En `InventarioController`, cada vez que se ejecute una reserva o devolución, refrescar la tabla con `listar_perfiles_por_obra(id_obra)` y recargar los perfiles en el dropdown.
3.3. Test unitario para InventarioModel (Perfiles)
markdown
Copiar
Editar
Crea `tests/inventario/test_inventario_perfiles_model.py` que:
1. Use un fixture de SQLite en memoria para crear tablas: `inventario_perfiles`, `perfiles_por_obra`, `movimientos_stock`, `auditorias_sistema`.
2. Inserte un perfil con `id_perfil=1, nombre='Perfil1', stock_actual=10, stock_minimo=3, precio_unitario=50`.
3. Pruebe `test_reservar_perfil_exitoso` que:
   - Llame a `reservar_perfil(obra_id=1, id_perfil=1, cantidad=5)` y verifique que ahora `stock_actual` es 5.
   - Compruebe que en `perfiles_por_obra` hay fila con `cantidad_reservada=5` y `estado='Reservado'`.
   - Verifique que en `movimientos_stock` exista un registro con `tipo_movimiento='Egreso'` y `cantidad=5`.
4. Pruebe `test_reservar_perfil_insuficiente` que:
   - Llame a `reservar_perfil(obra_id=1, id_perfil=1, cantidad=20)` y espere `ValueError("Stock insuficiente")`.
5. Pruebe `test_devolver_perfil_exitoso` que:
   - Primero haga una reserva (llama a `reservar_perfil`).
   - Luego `devolver_perfil(obra_id=1, id_perfil=1, cantidad=3)` y verifique que `stock_actual` quedó en 8.
   - Que el registro en `perfiles_por_obra` se haya actualizado o eliminado.
   - Que en `movimientos_stock` exista un registro con `tipo_movimiento='Ingreso'` y `cantidad=3`.
6. Pruebe `test_ajustar_stock_invalido` que:
   - Llame a `ajustar_stock_perfil(id_perfil=1, nueva_cantidad=-2, usuario="test")` y espere `ValueError("Cantidad inválida")`.
3.4. Test de integración para InventarioController (Perfiles)
markdown
Copiar
Editar
Crea `tests/inventario/test_inventario_perfiles_controller.py` que:
1. Use un MockDBConnection en SQLite memoria para las mismas tablas que el modelo.
2. Simule un usuario con permiso “crear” y llame `reservar_material(id_perfil=1, cantidad=5, id_obra=1)` en `InventarioController`. Verifique:
   - Que no arroja error.
   - Que en la BD `inventario_perfiles.stock_actual` es 5.
   - Que en auditoría existe “Usuario Test reservó 5 del perfil 1 para obra 1”.
3. Simule un usuario sin permiso “crear” e intente `reservar_material`, espere `ValueError("Permisos insuficientes")`.
4. Simule `devolver_material(id_perfil=1, cantidad=3, id_obra=1)` con permiso “editar” y verifique:
   - `stock_actual` pasó a 8.
   - Auditoría “Usuario Test devolvió 3 del perfil 1 de la obra 1”.
5. Sin permiso “editar”, `devolver_material` debe lanzar `ValueError("Permisos insuficientes")`.
4. Herrajes y Vidrios
4.1. Métodos en HerrajesModel
markdown
Copiar
Editar
En `modules/herrajes/model.py`, implementa:
1. `def reservar_herraje(self, id_obra, id_herraje, cantidad):`
   - Si `cantidad > stock_actual` en `herrajes`, lanzar `ValueError("Stock insuficiente")`.
   - Restar `stock_actual -= cantidad`.
   - Insertar/actualizar en `herrajes_por_obra(id_obra, id_herraje, cantidad_reservada, estado='Reservado')`.
   - Insertar en `movimientos_herrajes(id_herraje, tipo_movimiento='Egreso', cantidad, fecha=NOW(), usuario)`.
   - Registrar auditoría “Usuario X reservó {cantidad} del herraje {id_herraje} para obra {id_obra}”.
   - Retornar True.
2. `def devolver_herraje(self, id_obra, id_herraje, cantidad):`
   - Aumentar `stock_actual += cantidad`.
   - Actualizar o eliminar fila en `herrajes_por_obra`.
   - Insertar en `movimientos_herrajes(tipo_movimiento='Ingreso', cantidad, fecha=NOW(), usuario)`.
   - Registrar auditoría “Usuario X devolvió {cantidad} del herraje {id_herraje} de la obra {id_obra}”.
   - Retornar True.
3. `def ajustar_stock_herraje(self, id_herraje, nueva_cantidad, usuario):`
   - Si `nueva_cantidad < 0`, lanzar `ValueError("Cantidad inválida")`.
   - Obtener `stock_anterior`, actualizar `stock_actual = nueva_cantidad`.
   - Insertar en `movimientos_herrajes(tipo_movimiento='Ajuste', cantidad=abs(nueva_cantidad − stock_anterior), fecha=NOW(), usuario)`.
   - Registrar auditoría “Usuario X ajustó stock del herraje {id_herraje} de {stock_anterior} a {nueva_cantidad}”.
   - Retornar True.
Usa transacciones con timeout=30 y retries=2.
4.2. Métodos en VidriosModel
python
Copiar
Editar
En `modules/vidrios/model.py`, implementa de forma análoga a HerrajesModel:
1. `def reservar_vidrio(self, id_obra, id_vidrio, cantidad):`
   - Validar stock_actual ≥ cantidad.
   - Restar stock_actual, insertar/actualizar en `vidrios_por_obra`.
   - Insertar en `movimientos_vidrios(tipo_movimiento='Egreso', cantidad, fecha=NOW(), usuario)`.
   - Registrar auditoría “Usuario X reservó {cantidad} del vidrio {id_vidrio} para obra {id_obra}”.
   - Retornar True.
2. `def devolver_vidrio(self, id_obra, id_vidrio, cantidad):`
   - Aumentar stock_actual, actualizar/eliminar `vidrios_por_obra`.
   - Insertar `movimientos_vidrios(tipo_movimiento='Ingreso', cantidad, fecha=NOW(), usuario)`.
   - Registrar auditoría “Usuario X devolvió {cantidad} del vidrio {id_vidrio} de la obra {id_obra}”.
   - Retornar True.
3. `def ajustar_stock_vidrio(self, id_vidrio, nueva_cantidad, usuario):`
   - Si nueva_cantidad < 0, lanzar `ValueError("Cantidad inválida")`.
   - Actualizar stock_actual, insertar en `movimientos_vidrios(tipo_movimiento='Ajuste', cantidad=abs(nueva_cantidad − stock_anterior), fecha=NOW(), usuario)`.
   - Registrar auditoría “Usuario X ajustó stock del vidrio {id_vidrio} de {stock_anterior} a {nueva_cantidad}”.
   - Retornar True.
Usa transacciones con timeout=30 y retries=2.
4.3. UI de Herrajes y Vidrios en View/Controller
markdown
Copiar
Editar
En `modules/herrajes/view.py` y `modules/herrajes/controller.py`:
1. En el Controller, definir señales:
   - `reservar_herraje_signal(id_obra, id_herraje, cantidad)`.
   - `devolver_herraje_signal(id_obra, id_herraje, cantidad)`.
   - Conectar esas señales a los métodos `reservar_herraje` y `devolver_herraje` del modelo.
2. En la Vista (`HerrajesView`):
   - `QComboBox` con lista de obras (id_obra).
   - `QComboBox` o `QLineEdit+QCompleter` con lista de herrajes (nombre y stock_actual).
   - `QSpinBox` para cantidad.
   - Botón “Reservar herraje” que emita `reservar_herraje_signal`.
   - Botón “Devolver herraje” que emita `devolver_herraje_signal`.
   - `QTableWidget` para “Herrajes por Obra” mostrando [NombreHerraje, CantidadReservada, Estado, Fecha].
   - Colorear en rojo las filas cuyo stock_actual ≤ stock_minimo.

En `modules/vidrios/view.py` y `modules/vidrios/controller.py` haz lo mismo para vidrios.
4.4. Tests para HerrajesModel y VidriosModel
markdown
Copiar
Editar
Crea `tests/herrajes/test_herrajes_model.py`:
1. Fixture SQLite en memoria con tablas: `herrajes`, `herrajes_por_obra`, `movimientos_herrajes`, `auditorias_sistema`.
2. Inserte un herraje con `id_herraje=1, stock_actual=20, stock_minimo=5`.
3. Pruebas:
   - `test_reservar_herraje_exitoso`: reservar 10 y comprobar stock pasa a 10, reserva en `herrajes_por_obra` y movimiento “Egreso”.
   - `test_reservar_herraje_insuficiente`: intentar reservar 30 y esperar `ValueError("Stock insuficiente")`.
   - `test_devolver_herraje_exitoso`: reservar 10, luego devolver 5, comprobar stock=15, movimiento “Ingreso”.
   - `test_ajustar_stock_herraje_invalido`: llamar con nueva_cantidad=-3 y esperar `ValueError("Cantidad inválida")`.

Crea `tests/vidrios/test_vidrios_model.py` análogo a herrajes, pero con tablas `vidrios`, `vidrios_por_obra`, `movimientos_vidrios`.
4.5. Tests para HerrajesController y VidriosController
markdown
Copiar
Editar
Crea `tests/herrajes/test_herrajes_controller.py`:
1. Fixture con MockDBConnection para herrajes.
2. Usuario “Admin” con permiso “crear” llame `asociar_herraje(obra_id=1, id_herraje=1, cantidad=5)` y verifique DB y auditoría.
3. Usuario sin permiso “crear” espere `ValueError("Permisos insuficientes")`.
4. Usuario con permiso “editar” llame `devolver_herraje_control(obra_id=1, id_herraje=1)` y verifique DB y auditoría.
5. Sin permiso “editar” espere `ValueError("Permisos insuficientes")`.

Crea `tests/vidrios/test_vidrios_controller.py` con el mismo esquema para vidrios.
5. “Perfiles por obra” y “Lista de Precios”
5.1. Consultar perfiles por obra en InventarioModel
python
Copiar
Editar
En `modules/inventario/model.py` agrega:
```python
def obtener_perfiles_por_obra(self, id_obra):
    """
    Retorna lista de tuplas (nombre_perfil, cantidad_reservada, estado, fecha)
    para todos los perfiles asociados a id_obra.
    """
    sql = '''
      SELECT p.nombre_perfil, pp.cantidad_reservada, pp.estado, pp.fecha
      FROM perfiles_por_obra pp
      JOIN inventario_perfiles p ON pp.id_perfil = p.id_perfil
      WHERE pp.id_obra = ?
    '''
    return self.db.select_all(sql, (id_obra,))
shell
Copiar
Editar

### 5.2. UI para “Perfiles por Obra” en InventarioView
En modules/inventario/view.py, dentro de la clase InventarioView:

Agrega una nueva pestaña o sección “Perfiles por Obra” con un QTableWidget que muestre columnas [Perfil, CantidadReservada, Estado, Fecha].

En el Controller, define el método cargar_perfiles_por_obra(self, id_obra) que llame a InventarioModel.obtener_perfiles_por_obra(id_obra) y cargue los datos en la tabla.

En la UI, cada vez que se seleccione una obra del primer QComboBox, llame a cargar_perfiles_por_obra(id_obra).

shell
Copiar
Editar

### 5.3. Lista de precios de perfiles
En modules/inventario/controller.py, agrega:

python
Copiar
Editar
def obtener_lista_precios(self):
    """
    Retorna lista de tuplas (id_perfil, nombre_perfil, precio_unitario, stock_actual, stock_minimo).
    """
    sql = '''
      SELECT id_perfil, nombre_perfil, precio_unitario, stock_actual, stock_minimo
      FROM inventario_perfiles
    '''
    return self.db.select_all(sql)
En modules/inventario/view.py, crea una pestaña “Precios” con:

QTableWidget con columnas [Perfil, Precio unitario, Stock Actual, Stock Mínimo].

Botón “Editar precio” que abra un diálogo donde el usuario (si tiene permiso “editar”) pueda cambiar el precio. Al confirmar, llamar a InventarioController.actualizar_precio_perfil(id_perfil, nuevo_precio).

En el Controller, implementa actualizar_precio_perfil(id_perfil, nuevo_precio) que valide nuevo_precio ≥ 0, actualice inventario_perfiles.precio_unitario, registre auditoría “Usuario X actualizó precio del perfil {id_perfil} a {nuevo_precio}” y recargue la grilla.

shell
Copiar
Editar

### 5.4. Tests para “Perfiles por Obra” y “Precios”
Crea tests/inventario/test_perfiles_por_obra_model.py:

Fixture SQLite en memoria con tablas inventario_perfiles y perfiles_por_obra.

Inserte un perfil y una reserva para obra=1.

Llame obtener_perfiles_por_obra(1) y verifique que retorne (nombre_perfil, cantidad_reservada, estado, fecha).

Crea tests/inventario/test_precios_perfiles_controller.py:

Fixture con MockDBConnection.

Usuario con permiso “editar” llame actualizar_precio_perfil(id_perfil=1, nuevo_precio=200) y verifique que inventario_perfiles.precio_unitario pasó de su valor inicial a 200.
Verifique auditoría “Usuario Test actualizó precio del perfil 1 a 200”.

Usuario sin permiso “editar” llame a actualizar_precio_perfil y espere ValueError("Permisos insuficientes").

yaml
Copiar
Editar

---

## 6. Módulo “Configuración” y “Usuarios/Roles”

### 6.1. Probar conexión en ConfiguraciónController
En modules/configuracion/controller.py, implementa:

python
Copiar
Editar
def probar_conexion_db(self, server, database, user, password, port):
    """
    1. Intente conectarse a la base usando pyodbc.connect con la cadena DSN adecuada.
    2. Si la conexión es exitosa, retorne True.
    3. Si falla, capture la excepción y retorne False o lance ValueError(f"No se pudo conectar: {error}").
    """
    try:
        conn_string = f"DRIVER={{SQL Server}};SERVER={server},{port};DATABASE={database};UID={user};PWD={password}"
        conn = pyodbc.connect(conn_string, timeout=5)
        conn.close()
        return True
    except Exception as e:
        raise ValueError(f"No se pudo conectar: {e}")
En modules/configuracion/view.py, conecta el botón “Probar conexión” para que llame a este método y muestre QMessageBox apropiado según True/False.

shell
Copiar
Editar

### 6.2. Guardar y leer configuración desde BD
En modules/configuracion/model.py, implementa:

python
Copiar
Editar
def guardar_config(self, datos_config):
    """
    Inserta o actualiza la fila única en tabla 'configuraciones' con claves:
    theme, idioma, timezone, etc.
    """
    sql_exists = "SELECT COUNT(1) FROM configuraciones"
    count = self.db.select_one(sql_exists)[0]
    if count == 0:
        sql = "INSERT INTO configuraciones(theme, idioma, timezone) VALUES (?, ?, ?)"
        self.db.execute(sql, (datos_config['theme'], datos_config['idioma'], datos_config['timezone']))
    else:
        sql = "UPDATE configuraciones SET theme=?, idioma=?, timezone=?"
        self.db.execute(sql, (datos_config['theme'], datos_config['idioma'], datos_config['timezone']))
En modules/configuracion/controller.py, al iniciar la app, llame a model.obtener_config() y cargue los valores en core/config.py para aplicar el tema e idioma.

shell
Copiar
Editar

### 6.3. Gestión de usuarios y permisos
En modules/usuarios/controller.py, implementa:

crear_usuario(self, username, password, rol_id) que:

Valide que username no exista (SELECT COUNT(*) FROM usuarios WHERE username=?).

Hashee la contraseña (bcrypt) y guarde en usuarios(username, password_hash, rol_id).

Llamar a asignar_permisos_por_rol(rol_id) para llenar permisos_por_usuario.

Registrar auditoría “Usuario Admin creó al usuario {username} con rol {rol_id}”.

editar_permisos_usuario(self, user_id, nuevos_permisos_dict) que:

Actualice permisos_por_usuario según el dict.

Registrar auditoría “Usuario Admin actualizó permisos de {user_id}”.

Emitir señal para recargar el Sidebar (por ejemplo, EventBus.publish("PermisosActualizados", user_id)).

En modules/usuarios/view.py, cuando se modifiquen permisos, la UI del Sidebar recargue dinámicamente sin necesidad de reiniciar la app.

shell
Copiar
Editar

### 6.4. Tests para Configuración y Usuarios
Crea tests/usuarios/test_usuarios_model.py:

Fixture SQLite en memoria con tablas usuarios, roles, permisos_por_rol, permisos_por_usuario.

Prueba test_crear_usuario_exitoso que:

Llame crear_usuario("user1","P@ssw0rd", rol_id=2) y verifique:

En la tabla usuarios existe el username “user1” y password_hash no es vacío.

En permisos_por_usuario existan las filas heredadas de permisos_por_rol para rol_id=2.

Prueba test_crear_usuario_usuario_duplicado que:

Inserte manualmente “user2” y luego llame a crear_usuario("user2","abc",1) y espere ValueError("Usuario ya existe").

Prueba test_editar_permisos que:

Llame a editar_permisos_usuario(user_id, {'obras':{'ver':False,...}, ...}) y verifique que en permisos_por_usuario se actualicen correctamente.

Crea tests/configuracion/test_configuracion_controller.py:

Fixture SQLite en memoria con tabla configuraciones.

Prueba test_probar_conexion_correcta que:

Use credenciales válidas (puede mockear pyodbc.connect para devolver conexión simulada) y verifique que probar_conexion_db(...) retorne True.

Prueba test_probar_conexion_incorrecta que:

Mockee pyodbc.connect para lanzar excepción y verifique que probar_conexion_db(...) lance ValueError("No se pudo conectar: ...").

Prueba test_guardar_y_leer_config que:

Llame a guardar_config({'theme':'dark','idioma':'es','timezone':'America/Argentina/Buenos_Aires'}).

Verifique que obtener_config() retorne exactamente esos valores.

yaml
Copiar
Editar

---

## 7. Módulo “Contabilidad” (Facturas y Pagos)

### 7.1. Generar factura en ContabilidadModel
En modules/contabilidad/model.py, implementa:

python
Copiar
Editar
def generar_factura_por_pedido(self, id_pedido):
    """
    1. Consulte pedidos_por_obra y precios unitarios para el id_pedido.
    2. Calcule total = SUM(cantidad_recibida * precio_unitario).
    3. Inserte en facturas(id_pedido, fecha_emision=NOW(), total, estado='Pendiente') y recupere id_factura.
    4. Registrar auditoría “Usuario X generó factura {id_factura} para pedido {id_pedido}”.
    5. Retornar id_factura.
    """
    # Implementar con transacción timeout=30, retries=2
shell
Copiar
Editar

### 7.2. Registrar pago en ContabilidadModel
En modules/contabilidad/model.py, implementa:

python
Copiar
Editar
def registrar_pago(self, id_factura, monto, forma_pago, usuario):
    """
    1. Consulte la factura para obtener total y estado.
    2. Si estado != 'Pendiente', lance ValueError("Factura ya pagada" o similar).
    3. Si monto > total, lance ValueError("Monto excede total de la factura").
    4. Inserte en pagos(id_factura, monto, fecha_pago=NOW(), forma_pago).
    5. Si monto == total, actualice facturas.estado='Pagada'; si monto < total, actualice facturas.saldo_restante = total - monto.
    6. Registrar auditoría “Usuario X registró pago de {monto} a factura {id_factura}”.
    7. Retornar True.
    """
    # Implementar con transacción timeout=30, retries=2
shell
Copiar
Editar

### 7.3. UI y Controller de Contabilidad
En modules/contabilidad/controller.py y modules/contabilidad/view.py:

En el Controller, defina señales:

generar_factura_signal(id_pedido) que conecta a generar_factura_por_pedido.

registrar_pago_signal(id_factura, monto, forma_pago) que conecta a registrar_pago.

ver_balance_signal() que conecta a obtener_balance().

En el View:

Pestaña “Facturas Pendientes”:

QTableWidget que muestre facturas con estado “Pendiente” (columnas: ID, Pedido, Total, FechaEmisión).

Botón “Generar factura” que abra un diálogo con dropdown de pedidos “Recibidos sin factura” y emita generar_factura_signal.

Pestaña “Registrar Pago”:

Dropdown de facturas pendientes.

QDoubleSpinBox para monto.

Dropdown QComboBox para forma de pago (Efectivo, Transferencia, Cheque).

Botón “Registrar pago” que emita registrar_pago_signal.

Pestaña “Balance General”:

QLabel que muestre “Total pendiente: $X”, “Total pagado: $Y”, “Facturas pendientes: N”, “Facturas pagadas: M”.

(Opcional) Un FigureCanvas de matplotlib que dibuje un gráfico de barras con facturación mensual (datos obtenidos de obtener_balance()).

Cada acción que invoque un método del modelo debe capturar ValueError y mostrar QMessageBox.warning.

graphql
Copiar
Editar

### 7.4. Tests para ContabilidadModel y Controller
Crea tests/contabilidad/test_contabilidad_model.py:

Fixture SQLite en memoria con tablas: pedidos, pedidos_por_obra, facturas, pagos, productos (con precios unitarios).

Inserte un pedido con id_pedido=1 y entradas en pedidos_por_obra:

id_vidrio=1, cantidad_recibida=5, precio_unitario=200.

id_perfil=2, cantidad_recibida=10, precio_unitario=100.

Prueba test_generar_factura:

Llame a generar_factura_por_pedido(1) y verifique:

Se inserta factura con total = 5200 + 10100 = 2000.

Estado “Pendiente”.

Auditoría “Usuario X generó factura {id_factura} para pedido 1”.

Prueba test_registrar_pago_parcial:

Inserte una factura con total=2000, estado “Pendiente”.

Llame a registrar_pago(id_factura, monto=500, forma_pago="Efectivo", usuario="test").

Verifique que en pagos exista registro, en facturas saldo_restante=1500 y estado sigue “Pendiente”.

Verifique auditoría “Usuario test registró pago de 500 a factura {id_factura}”.

Prueba test_registrar_pago_total:

Inserte factura con total=2000, estado “Pendiente”.

Llame a registrar_pago(id_factura, monto=2000, forma_pago="Transferencia", usuario="test").

Verifique estado “Pagada” en facturas.

Verifique auditoría “Usuario test registró pago de 2000 a factura {id_factura}”.

Crea tests/contabilidad/test_contabilidad_controller.py:

Fixture con MockDBConnection en memoria con las mismas tablas.

Prueba test_generar_factura_con_permisos:

Simule usuario Admin con permiso “crear”, llame crear_factura(id_pedido=1) y verifique que se llamó a generar_factura_por_pedido y auditoría.

Prueba test_generar_factura_sin_permisos:

Usuario sin permiso “crear” espere ValueError("Permisos insuficientes").

Prueba test_registrar_pago_con_permisos:

Simule factura existente y usuario con permiso “crear”, llame registrar_pago(id_factura=1, monto=2000, forma_pago="Cheque") y verifique DB y auditoría.

Prueba test_registrar_pago_sin_permisos:

Usuario sin permiso “crear” espere ValueError("Permisos insuficientes").

yaml
Copiar
Editar

---

## 8. Módulo “Auditoría” (Historial y Exportación)

### 8.1. Filtrar auditorías en AuditoriaModel
En modules/auditoria/model.py, implementa:

python
Copiar
Editar
def contar_auditorias(self, fecha_desde=None, fecha_hasta=None, modulo=None, usuario=None):
    """
    Construya un SQL dinámico:
      SELECT COUNT(*) FROM auditorias_sistema WHERE 1=1
      (agregar AND fecha >= ? si fecha_desde dado)
      (AND fecha <= ? si fecha_hasta dado)
      (AND modulo = ? si modulo dado)
      (AND usuario = ? si usuario dado)
    Retorne el entero del COUNT.
    """

def listar_auditorias(self, fecha_desde=None, fecha_hasta=None, modulo=None, usuario=None, offset=0, limit=50):
    """
    Mismo WHERE que contar_auditorias, más:
      ORDER BY fecha DESC
      OFFSET ? ROWS FETCH NEXT ? ROWS ONLY
    Retorne lista de tuplas (usuario, modulo, accion, fecha).
    """
Usa consultas parametrizadas para evitar inyección SQL.

shell
Copiar
Editar

### 8.2. Exportar auditorías a Excel en AuditoriaController
En modules/auditoria/controller.py, implementa:

python
Copiar
Editar
def exportar_excel(self, filtros):
    """
    1. Llame a model.contar_auditorias con filtros para obtener total.
    2. Llame a model.listar_auditorias con offset=0, limit=total para obtener todas las filas.
    3. Convierta el resultado a pandas.DataFrame con columnas ["Usuario","Módulo","Acción","Fecha"].
    4. Genere nombre de archivo: f"exports/auditorias_{datetime.now():%Y%m%d_%H%M%S}.xlsx".
    5. Use df.to_excel(ruta) para guardar.
    6. Registrar auditoría “Usuario X exportó auditoría a Excel: <ruta>”.
    7. Retornar la ruta del archivo.
    """
shell
Copiar
Editar

### 8.3. UI de Auditoría en View y Controller
En modules/auditoria/view.py y modules/auditoria/controller.py:

En la Vista, diseñar:

Dos QDateEdit para “Desde” y “Hasta”.

QComboBox con opciones de “Todos” + lista de módulos (Obras, Inventario, etc.).

QLineEdit para “Usuario”.

Botón “Filtrar” que emita filtrar_auditorias_signal(dict_filtros, pagina=1).

QTableWidget con columnas [Usuario, Módulo, Acción, Fecha].

Botones “Anterior” y “Siguiente” con un QLabel “Página X de Y”.

Botón “Exportar a Excel” que emita exportar_excel_signal(dict_filtros).

En el Controller, conecte:

signal_filtrar_auditorias a filtrar_auditorias(filtros, pagina):

Calcule offset = (pagina - 1)* limit.

Llame a model.contar_auditorias(...) y model.listar_auditorias(..., offset, limit).

Llame a view.actualizar_tabla(registros, total, pagina).

signal_exportar_excel a exportar_excel(filtros), que obtenga la ruta del archivo y muestre QMessageBox.information(f"Exportado a: {ruta}").

Asegúrate de deshabilitar “Anterior” si pagina == 1 y “Siguiente” si offset + limit ≥ total.

shell
Copiar
Editar

### 8.4. Tests para AuditoríaModel y Controller
Crea tests/auditoria/test_auditoria_model.py:

Fixture SQLite en memoria con tabla auditorias_sistema.

Inserte varios registros con usuarios “admin”, “user1” en distintos módulos y fechas escalonadas.

Pruebe test_contar_sin_filtros que contar_auditorias() retorne el número total.

Pruebe test_contar_con_filtros que contar_auditorias(fecha_desde, fecha_hasta, modulo="Obras", usuario="admin") retorne la cuenta adecuada.

Pruebe test_listar_offset_limit que listar_auditorias(..., offset=0, limit=5) devuelva 5 filas ordenadas por fecha descendente.

Crea tests/auditoria/test_auditoria_controller.py:

Fixture MockDBConnection en memoria con datos idénticos.

Pruebe test_filtrar_auditorias que:

Llame filtrar_auditorias(filtros, pagina=2) y mockee view.actualizar_tabla para capturar sus argumentos.

Verifique que recibe (registros, total, pagina) correctos.

Pruebe test_exportar_excel que:

Llame exportar_excel(filtros), verifique que devuelve una ruta que existe en exports/.

Mockee view.mostrar_mensaje y verifique que se muestre “Exportado a: <ruta>”.

yaml
Copiar
Editar

---

## 9. Integración “Obras → Inventario → Pedidos → Contabilidad” (E2E)

### 9.1. Test E2E de flujo completo
Crea tests/e2e/test_flujo_completo.py usando pytest-qt que:

Inicie la aplicación principal (MainWindow) con qtbot y registre un usuario Admin en MockDBConnection.

Login como Admin.

Cree una obra “ObraPrueba” desde la UI:

Haga clic en el botón “Agregar Obra”, complete los campos (nombre, cliente, fecha med., fecha ent.), clic “Guardar”.

Verifique que en la tabla de Obras aparezca “ObraPrueba”.

Desde la pestaña “Inventario → Perfiles”:

Seleccione la obra “ObraPrueba”.

Elija un perfil (por ejemplo “Perfil1” con stock ≥ 10), ingrese cantidad=5 y clique “Reservar”.

Verifique que en la grilla “Perfiles por Obra” aparezca la fila con “Perfil1” y “5” unidades.

Vaya a “Compras → Pedidos”:

Seleccione “ObraPrueba” y clique “Generar pedido”.

En el diálogo, verifique que el listado muestre “Perfil1” con “Cantidad pendiente = 5”.

Clique “Confirmar pedido” y espere a que se cierre el dialog.

Verifique en la tabla “Pedidos” que exista un pedido con estado “Pendiente” y total estimado = 5 * (precio unitario).

En “Pedidos”, seleccione el pedido recién creado y clique “Recibir pedido”.

Verifique que cambie a estado “Recibido”.

Vaya a “Inventario → Perfiles” y confirme que el stock de “Perfil1” aumentó en 5.

Vaya a “Contabilidad”:

En “Facturas Pendientes”, clique “Generar factura” para el pedido generado.

Verifique que la factura aparezca en la lista con estado “Pendiente” y total correcto.

Clique “Registrar pago” para esa factura, ingrese monto igual al total, clic “Guardar”.

Verifique que la factura desaparezca de “Pendientes” y aparezca en “Pagadas”.

Vaya a “Auditoría”:

Aplique un filtro con módulo=”Obras” y usuario=“Admin” y asegúrese de que exista un registro “Creó obra …”.

Exporte a Excel y verifique que el archivo exista en exports/.

Al final, cierre la app.

yaml
Copiar
Editar

---

## 10. UI/UX, Accesibilidad y Estilos

### 10.1. Añadir tooltips y efectos de sombra
En cada View correspondiente (modules/obras/view.py, modules/inventario/view.py, etc.):

Para cada QLineEdit, QComboBox y QPushButton, llame a setToolTip("Descripción breve y clara").

Para los botones principales y tarjetas, aplique QGraphicsDropShadowEffect con:

python
Copiar
Editar
from PyQt6.QtWidgets import QGraphicsDropShadowEffect
from PyQt6.QtGui import QColor

sombra = QGraphicsDropShadowEffect(widget)
sombra.setBlurRadius(16)
sombra.setColor(QColor(37, 99, 235, 60))
sombra.setOffset(0, 4)
widget.setGraphicsEffect(sombra)
Aplica esto, por ejemplo, a los botones “Guardar”, “Reservar”, “Generar pedido”.

Eliminar cualquier setStyleSheet embebido en el código y asegurarse de que los estilos estén en resources/qss/theme_light.qss y theme_dark.qss.

shell
Copiar
Editar

### 10.2. Ajustar margenes y separación en Sidebar via QSS
En resources/qss/theme_light.qss y theme_dark.qss, agrega o revisa:

css
Copiar
Editar
QWidget#sidebar { background-color: #FFFFFF; }
QPushButton#sidebarBoton {
    margin: 4px 0;
    padding: 4px 8px;
    border: 1px solid #e3e3e3;
    border-radius: 8px;
    font-size: 12px;
    text-align: left;
}
QPushButton#sidebarBoton:hover { background-color: #e3f6fd; }
QPushButton#sidebarBoton:pressed { background-color: #d1f7e7; }
QPushButton#sidebarBotonLogs,
QPushButton#sidebarBotonAyuda { margin: 8px 0 4px 0; }
QPushButton#sidebarThemeToggle { margin: 8px 0; }
QLabel#sidebarUserLabel { margin: 8px 0 4px 0; font-size: 11px; color: #222; }
Asegúrate de que cada SidebarButton tenga setObjectName("sidebarBoton") para que las reglas apliquen.

yaml
Copiar
Editar

---

## 11. Scripts de Base de Datos y Migraciones

### 11.1. Consolidación en `estructura_tablas_mps.sql`
Abre scripts/estructura_tablas_mps.sql y verifica que contenga:

Sentencias CREATE TABLE para:

usuarios, roles, permisos_por_rol, permisos_por_usuario

obras, etapas_obras

inventario_perfiles, perfiles_por_obra, movimientos_stock

herrajes, herrajes_por_obra, movimientos_herrajes

vidrios, vidrios_por_obra, movimientos_vidrios

pedidos, pedidos_por_obra

facturas, pagos

auditorias_sistema

Columnas clave:

rowversion en obras.

stock_minimo en tablas de inventario (perfiles, herrajes, vidrios).

Tipos ENUM o VARCHAR(20) para estados (ej. 'Pendiente', 'Recibido', 'Pagada').

Índices y claves foráneas:

FK obras(id_cliente) → clientes(id_cliente) si existe tabla clientes.

FK perfiles_por_obra(id_perfil) → inventario_perfiles(id_perfil).

FK movimientos_stock(id_perfil) → inventario_perfiles(id_perfil).

Equivalentes para herrajes y vidrios.

FK pedidos(id_obra) → obras(id_obra).

FK pedidos_por_obra(id_pedido) → pedidos(id_pedido).

FK facturas(id_pedido) → pedidos(id_pedido).

FK pagos(id_factura) → facturas(id_factura).

FK auditorias_sistema(usuario_id) → usuarios(id_usuario) (o almacenar nombre directo).

Si faltan tablas o columnas, agrégalas aquí en orden lógico.

shell
Copiar
Editar

### 11.2. Script de bootstrap de roles y permisos
En scripts/bootstrap_roles_permisos.sql, asegúrate de que:

Inserta roles base:

Admin (con todos los permisos “ver/crear/editar/eliminar/aprobar” en todos los módulos).

Operario (solo permisos “ver” y “crear” en Inventario, Pedidos; “ver” en Obras).

Contador (permiso “crear” y “ver” en Contabilidad; “ver” en Pedidos, Obras).

Auditor (permiso “ver” en Auditoría).

Inserta permisos_por_rol correspondientes para cada módulo con las banderas booleanas.

Crea un usuario “admin” con rol_id=1 y contraseña hasheada (bcrypt) en usuarios.

Crea un usuario de prueba “demo” con rol “Operario”.

yaml
Copiar
Editar

---

## 12. Documentación y Checklist de Release

### 12.1. Actualizar README.md
Modifica el archivo README.md para que incluya:

Instrucciones de instalación:

Clonar el repositorio git clone ....

Crear entorno virtual e instalar dependencias pip install -r requirements.txt.

Variables de entorno obligatorias (en .env.example):

DB_SERVER, DB_PORT, DB_DATABASE, DB_USER, DB_PASSWORD, DEFAULT_THEME, DEBUG_MODE, LOG_LEVEL.

Cómo ejecutar migraciones:

cd scripts y sqlcmd -S <server> -i estructura_tablas_mps.sql (o equivalente para PostgreSQL).

Cómo ejecutar bootstrap de roles:

sqlcmd -S <server> -i bootstrap_roles_permisos.sql.

Cómo iniciar la app:

python main.py.

Cómo correr tests:

pytest --maxfail=1 --disable-warnings --cov=modules.

Cómo empacar la app con PyInstaller (opcional).

Notas de la versión 1.1.0 y próximos pasos.

shell
Copiar
Editar

### 12.2. Crear CHANGELOG.md
Crea un archivo CHANGELOG.md con el formato:

[1.1.0] - YYYY-MM-DD
Añadido
Alta, edición y bloqueo optimista (rowversion) en Obras.

Generación automática de la primera etapa de cada obra.

Módulo completo de Pedidos (generar/recibir/actualizar stock).

Inventario de Perfiles con reserva, devolución y ajustes.

Módulos de Herrajes y Vidrios con funcionalidad completa.

UI de Lista de Precios de Perfiles editable.

Gestión de usuarios y permisos con refresh dinámico del Sidebar.

Módulo de Contabilidad (facturas y pagos).

Módulo de Auditoría con filtrado, paginación y exportación a Excel.

Flujo E2E: Obras → Inventario → Pedidos → Contabilidad.

Tests unitarios, de integración y E2E (pytest-qt) para todos los módulos.

Interfaz mejorada con tooltips, sombras y accesibilidad.

Scripts SQL unificados en estructura_tablas_mps.sql.

Bootstrap de usuarios/roles en bootstrap_roles_permisos.sql.

Corregido
Eliminación de duplicados en el Sidebar y ajustes de QSS.

Bloqueo de tests de UI (pytest-qt) habilitados.

Varios bugs de validaciones de fechas, stock insuficiente y errores silenciosos.

Pendiente
Reportes automáticos por email.

Migración de datos legacy.

Empaquetado multiplataforma.

Documentación final de migración legacy.